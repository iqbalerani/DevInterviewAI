import { FlashcardDeck } from '../types';

export const flashcardDecks: FlashcardDeck[] = [
  {
    id: 'react',
    title: 'React',
    description: 'Core concepts, hooks, patterns, and performance optimization.',
    icon: 'Atom',
    gradient: 'from-cyan-500 to-blue-600',
    category: 'Frontend',
    cards: [
      {
        id: 'react-1',
        front: 'What is the Virtual DOM and why does React use it?',
        back: 'The Virtual DOM is a lightweight in-memory representation of the real DOM. React uses it to batch and minimize actual DOM updates by diffing the virtual tree against the previous version, then applying only the necessary changes (reconciliation).',
        difficulty: 'beginner',
        tags: ['virtual-dom', 'fundamentals'],
      },
      {
        id: 'react-2',
        front: 'Explain the rules of React Hooks.',
        back: '1. Only call hooks at the top level (not inside loops, conditions, or nested functions). 2. Only call hooks from React function components or custom hooks. These rules ensure hooks are called in the same order every render so React can correctly preserve state.',
        difficulty: 'beginner',
        tags: ['hooks', 'rules'],
      },
      {
        id: 'react-3',
        front: 'What is the difference between useEffect and useLayoutEffect?',
        back: 'useEffect fires asynchronously after the browser paints. useLayoutEffect fires synchronously after DOM mutations but before the browser paints. Use useLayoutEffect when you need to read layout (e.g., measuring an element) and synchronously re-render before the user sees the intermediate state.',
        difficulty: 'intermediate',
        tags: ['hooks', 'effects'],
      },
      {
        id: 'react-4',
        front: 'How does React.memo work and when should you use it?',
        back: 'React.memo is a higher-order component that memoizes the rendered output. It performs a shallow comparison of props and skips re-rendering if props haven\'t changed. Use it for components that render often with the same props, but avoid premature optimization.',
        codeSnippet: 'const MemoizedChild = React.memo(({ name }: Props) => {\n  return <div>{name}</div>;\n});',
        difficulty: 'intermediate',
        tags: ['performance', 'memoization'],
      },
      {
        id: 'react-5',
        front: 'What is a React key and why is it important in lists?',
        back: 'Keys help React identify which items have changed, been added, or removed during reconciliation. Without stable keys, React may incorrectly reuse DOM nodes, causing bugs with component state. Never use array index as key if the list can be reordered.',
        difficulty: 'beginner',
        tags: ['lists', 'reconciliation'],
      },
      {
        id: 'react-6',
        front: 'Explain the useCallback hook and when to use it.',
        back: 'useCallback returns a memoized version of a callback that only changes if its dependencies change. It prevents unnecessary re-renders of child components that rely on reference equality for props (e.g., when passed to React.memo components or used in dependency arrays).',
        codeSnippet: 'const handleClick = useCallback(() => {\n  setCount(c => c + 1);\n}, []);',
        difficulty: 'intermediate',
        tags: ['hooks', 'performance'],
      },
      {
        id: 'react-7',
        front: 'What is React Context and what are its limitations?',
        back: 'Context provides a way to pass data through the component tree without prop drilling. Limitations: 1) Any consumer re-renders when the context value changes, even if it only uses part of the value. 2) Not suitable for high-frequency updates. 3) Can make component reuse harder.',
        difficulty: 'intermediate',
        tags: ['context', 'state-management'],
      },
      {
        id: 'react-8',
        front: 'What is Suspense and how does it work with lazy loading?',
        back: 'Suspense lets you declaratively specify a loading UI while waiting for asynchronous operations (like lazy-loaded components or data fetching). React.lazy() creates a component that is loaded dynamically, and Suspense catches the loading state to show a fallback.',
        codeSnippet: 'const LazyComp = React.lazy(() => import("./Heavy"));\n\n<Suspense fallback={<Spinner />}>\n  <LazyComp />\n</Suspense>',
        difficulty: 'intermediate',
        tags: ['suspense', 'code-splitting'],
      },
      {
        id: 'react-9',
        front: 'What is a controlled vs uncontrolled component?',
        back: 'Controlled: form data is handled by React state. The component\'s value is driven by state and updated via onChange. Uncontrolled: form data is handled by the DOM itself using refs. Controlled components are preferred for validation and dynamic forms.',
        difficulty: 'beginner',
        tags: ['forms', 'patterns'],
      },
      {
        id: 'react-10',
        front: 'Explain React\'s concurrent rendering and what problems it solves.',
        back: 'Concurrent rendering allows React to prepare multiple versions of the UI simultaneously without blocking the main thread. It enables features like Suspense for data fetching, transitions (useTransition), and deferred values (useDeferredValue), keeping the UI responsive during expensive updates.',
        difficulty: 'advanced',
        tags: ['concurrent', 'performance'],
      },
    ],
  },
  {
    id: 'typescript',
    title: 'TypeScript',
    description: 'Type system, generics, utility types, and advanced patterns.',
    icon: 'FileCode2',
    gradient: 'from-blue-500 to-indigo-600',
    category: 'Frontend',
    cards: [
      {
        id: 'ts-1',
        front: 'What is the difference between `interface` and `type` in TypeScript?',
        back: 'Both can describe object shapes, but interfaces support declaration merging and extending with `extends`. Types support unions, intersections, mapped types, and conditional types. Use interface for objects/classes, type for unions and complex type compositions.',
        difficulty: 'beginner',
        tags: ['types', 'fundamentals'],
      },
      {
        id: 'ts-2',
        front: 'Explain the `unknown` type vs `any` type.',
        back: '`any` disables type checking entirely. `unknown` is the type-safe counterpart: you can assign anything to it, but you must narrow the type before using it. Prefer `unknown` over `any` for values whose type you don\'t know at compile time.',
        codeSnippet: 'function process(val: unknown) {\n  if (typeof val === "string") {\n    console.log(val.toUpperCase()); // OK\n  }\n}',
        difficulty: 'beginner',
        tags: ['types', 'safety'],
      },
      {
        id: 'ts-3',
        front: 'What are generic constraints and how do you use them?',
        back: 'Generic constraints restrict what types can be passed to a generic parameter using `extends`. This ensures the generic type has certain properties, enabling safe access to those properties inside the function.',
        codeSnippet: 'function getLength<T extends { length: number }>(item: T): number {\n  return item.length;\n}',
        difficulty: 'intermediate',
        tags: ['generics', 'constraints'],
      },
      {
        id: 'ts-4',
        front: 'What is a discriminated union and when would you use one?',
        back: 'A discriminated union uses a common literal property (the discriminant) to distinguish between members. TypeScript narrows the type based on the discriminant in switch/if statements. Perfect for state machines, API responses, or action types.',
        codeSnippet: 'type Result =\n  | { status: "ok"; data: string }\n  | { status: "error"; message: string };\n\nfunction handle(r: Result) {\n  if (r.status === "ok") r.data; // narrowed\n}',
        difficulty: 'intermediate',
        tags: ['unions', 'patterns'],
      },
      {
        id: 'ts-5',
        front: 'Explain `Partial<T>`, `Required<T>`, `Pick<T, K>`, and `Omit<T, K>`.',
        back: 'Partial<T>: makes all properties optional. Required<T>: makes all properties required. Pick<T, K>: creates a type with only the specified keys. Omit<T, K>: creates a type without the specified keys. These are built-in mapped utility types.',
        difficulty: 'beginner',
        tags: ['utility-types'],
      },
      {
        id: 'ts-6',
        front: 'What are conditional types in TypeScript?',
        back: 'Conditional types select one of two types based on a condition: `T extends U ? X : Y`. They enable type-level programming and are used in utility types like Extract, Exclude, and ReturnType.',
        codeSnippet: 'type IsString<T> = T extends string ? true : false;\ntype A = IsString<"hello">; // true\ntype B = IsString<42>;      // false',
        difficulty: 'advanced',
        tags: ['conditional-types', 'advanced'],
      },
      {
        id: 'ts-7',
        front: 'What is the `infer` keyword used for?',
        back: '`infer` is used within conditional types to extract (infer) a type from a pattern. It introduces a type variable that TypeScript resolves from the matched structure.',
        codeSnippet: 'type ReturnType<T> = T extends (...args: any[]) => infer R\n  ? R\n  : never;\n\ntype X = ReturnType<() => string>; // string',
        difficulty: 'advanced',
        tags: ['infer', 'conditional-types'],
      },
      {
        id: 'ts-8',
        front: 'What is declaration merging?',
        back: 'When two declarations with the same name exist, TypeScript merges them into a single definition. This works with interfaces (properties are combined), namespaces, and module augmentation. Types (type aliases) do NOT support declaration merging.',
        difficulty: 'intermediate',
        tags: ['interfaces', 'merging'],
      },
      {
        id: 'ts-9',
        front: 'What is the `satisfies` operator?',
        back: 'The `satisfies` operator (TS 4.9+) validates that an expression matches a type without widening it. Unlike type annotation, it preserves the narrower literal type while ensuring the value conforms to the expected shape.',
        codeSnippet: 'const config = {\n  width: 100,\n  color: "red",\n} satisfies Record<string, string | number>;\n// config.color is still "red", not string',
        difficulty: 'intermediate',
        tags: ['satisfies', 'narrowing'],
      },
      {
        id: 'ts-10',
        front: 'What are template literal types?',
        back: 'Template literal types build string types from other types using template literal syntax. Combined with union types, they can generate all permutations of string patterns.',
        codeSnippet: 'type Color = "red" | "blue";\ntype Size = "sm" | "lg";\ntype ClassName = `${Size}-${Color}`;\n// "sm-red" | "sm-blue" | "lg-red" | "lg-blue"',
        difficulty: 'advanced',
        tags: ['template-literals', 'string-types'],
      },
    ],
  },
  {
    id: 'docker',
    title: 'Docker',
    description: 'Containers, images, networking, volumes, and Docker Compose.',
    icon: 'Container',
    gradient: 'from-sky-500 to-cyan-600',
    category: 'DevOps',
    cards: [
      {
        id: 'docker-1',
        front: 'What is the difference between a Docker image and a container?',
        back: 'An image is a read-only template with instructions for creating a container. A container is a runnable instance of an image. You can create multiple containers from one image. Images are built from Dockerfiles; containers are created with `docker run`.',
        difficulty: 'beginner',
        tags: ['fundamentals'],
      },
      {
        id: 'docker-2',
        front: 'What is a multi-stage build and why use it?',
        back: 'Multi-stage builds use multiple FROM statements in a Dockerfile. Each stage can use a different base image. You copy only needed artifacts from build stages to the final image, resulting in much smaller production images without build tools or dependencies.',
        codeSnippet: 'FROM node:20 AS builder\nWORKDIR /app\nRUN npm ci && npm run build\n\nFROM node:20-alpine\nCOPY --from=builder /app/dist ./dist\nCMD ["node", "dist/index.js"]',
        difficulty: 'intermediate',
        tags: ['dockerfile', 'optimization'],
      },
      {
        id: 'docker-3',
        front: 'What is the difference between CMD and ENTRYPOINT?',
        back: 'ENTRYPOINT configures the container to run as an executable; it\'s harder to override. CMD provides default arguments that can be easily overridden at runtime. When used together, CMD provides default arguments to ENTRYPOINT.',
        difficulty: 'intermediate',
        tags: ['dockerfile'],
      },
      {
        id: 'docker-4',
        front: 'How does Docker layer caching work?',
        back: 'Each instruction in a Dockerfile creates a layer. Docker caches layers and reuses them if the instruction and all previous layers haven\'t changed. Order instructions from least to most frequently changing (e.g., COPY package.json before COPY src/) to maximize cache hits.',
        difficulty: 'intermediate',
        tags: ['caching', 'performance'],
      },
      {
        id: 'docker-5',
        front: 'What are Docker volumes and why are they needed?',
        back: 'Volumes are the preferred way to persist data generated by containers. Container filesystems are ephemeral—data is lost when the container is removed. Volumes are managed by Docker and stored outside the container\'s writable layer.',
        codeSnippet: 'docker volume create mydata\ndocker run -v mydata:/app/data myimage',
        difficulty: 'beginner',
        tags: ['volumes', 'persistence'],
      },
      {
        id: 'docker-6',
        front: 'Explain Docker networking modes.',
        back: 'Bridge (default): isolated network, containers communicate via IP/DNS. Host: shares host\'s network stack (no isolation). None: no networking. Overlay: spans multiple Docker hosts (Swarm). Macvlan: assigns a MAC address, appears as physical device on the network.',
        difficulty: 'intermediate',
        tags: ['networking'],
      },
      {
        id: 'docker-7',
        front: 'What is a .dockerignore file?',
        back: 'Like .gitignore but for Docker builds. It excludes files from the build context sent to the Docker daemon. This speeds up builds and prevents sensitive files (node_modules, .env, .git) from being included in the image.',
        difficulty: 'beginner',
        tags: ['best-practices'],
      },
      {
        id: 'docker-8',
        front: 'How do you reduce Docker image size?',
        back: '1. Use Alpine or slim base images. 2. Multi-stage builds. 3. Combine RUN commands to reduce layers. 4. Clean up caches in the same layer (apt-get clean). 5. Use .dockerignore. 6. Don\'t install unnecessary packages.',
        difficulty: 'intermediate',
        tags: ['optimization'],
      },
      {
        id: 'docker-9',
        front: 'What is Docker Compose and when do you use it?',
        back: 'Docker Compose is a tool for defining and running multi-container Docker applications using a YAML file. It manages service dependencies, networking, and volumes. Ideal for local development environments and simple multi-service deployments.',
        codeSnippet: 'services:\n  web:\n    build: .\n    ports: ["3000:3000"]\n  db:\n    image: postgres:16\n    volumes:\n      - pgdata:/var/lib/postgresql/data',
        difficulty: 'beginner',
        tags: ['compose'],
      },
      {
        id: 'docker-10',
        front: 'What are health checks in Docker and why are they important?',
        back: 'HEALTHCHECK instructions tell Docker how to test if a container is still working. Docker periodically runs the check command and marks containers as healthy/unhealthy. Orchestrators use this to restart unhealthy containers and manage traffic routing.',
        codeSnippet: 'HEALTHCHECK --interval=30s --timeout=5s \\\n  CMD curl -f http://localhost:3000/health || exit 1',
        difficulty: 'intermediate',
        tags: ['health', 'production'],
      },
    ],
  },
  {
    id: 'kubernetes',
    title: 'Kubernetes',
    description: 'Pods, services, deployments, scaling, and cluster management.',
    icon: 'Network',
    gradient: 'from-indigo-500 to-purple-600',
    category: 'DevOps',
    cards: [
      {
        id: 'k8s-1',
        front: 'What is a Pod in Kubernetes?',
        back: 'A Pod is the smallest deployable unit in Kubernetes. It represents one or more containers that share networking (same IP/port space) and storage. Containers in a pod are co-scheduled on the same node and can communicate via localhost.',
        difficulty: 'beginner',
        tags: ['pods', 'fundamentals'],
      },
      {
        id: 'k8s-2',
        front: 'What is a Deployment and how does it differ from a ReplicaSet?',
        back: 'A ReplicaSet ensures a specified number of pod replicas are running. A Deployment is a higher-level abstraction that manages ReplicaSets and provides declarative updates, rollback capabilities, and rolling update strategies. Always use Deployments over bare ReplicaSets.',
        difficulty: 'beginner',
        tags: ['deployments', 'replicasets'],
      },
      {
        id: 'k8s-3',
        front: 'Explain the different Service types in Kubernetes.',
        back: 'ClusterIP (default): internal cluster access only. NodePort: exposes on each node\'s IP at a static port. LoadBalancer: provisions an external load balancer (cloud). ExternalName: maps to a DNS name. Headless (clusterIP: None): returns pod IPs directly.',
        difficulty: 'intermediate',
        tags: ['services', 'networking'],
      },
      {
        id: 'k8s-4',
        front: 'What is a ConfigMap vs a Secret?',
        back: 'Both store configuration data as key-value pairs. ConfigMaps hold non-sensitive data (config files, env vars). Secrets hold sensitive data (passwords, tokens) and are base64-encoded (not encrypted by default). Both can be mounted as volumes or exposed as env vars.',
        difficulty: 'beginner',
        tags: ['configuration'],
      },
      {
        id: 'k8s-5',
        front: 'What are liveness, readiness, and startup probes?',
        back: 'Liveness: is the container alive? Fails → restart. Readiness: is the container ready to serve traffic? Fails → removed from service endpoints. Startup: has the container started? Used for slow-starting containers; disables liveness/readiness until it succeeds.',
        difficulty: 'intermediate',
        tags: ['probes', 'health'],
      },
      {
        id: 'k8s-6',
        front: 'What is a Namespace and when should you use multiple namespaces?',
        back: 'Namespaces provide logical isolation within a cluster. They partition resources and can have separate resource quotas and RBAC policies. Use multiple namespaces for environment separation (dev/staging/prod), team isolation, or multi-tenant clusters.',
        difficulty: 'beginner',
        tags: ['namespaces', 'organization'],
      },
      {
        id: 'k8s-7',
        front: 'Explain the Kubernetes rolling update strategy.',
        back: 'Rolling updates gradually replace old pods with new ones. `maxUnavailable` controls how many pods can be down. `maxSurge` controls how many extra pods can exist. This ensures zero-downtime deployments. Rollbacks are instant since old ReplicaSets are preserved.',
        codeSnippet: 'strategy:\n  type: RollingUpdate\n  rollingUpdate:\n    maxUnavailable: 1\n    maxSurge: 1',
        difficulty: 'intermediate',
        tags: ['deployments', 'updates'],
      },
      {
        id: 'k8s-8',
        front: 'What is an Ingress and how does it differ from a Service?',
        back: 'An Ingress manages external HTTP/HTTPS access to services. It provides URL-based routing, SSL termination, and name-based virtual hosting. Services expose pods internally or via L4. Ingress operates at L7 (HTTP) and requires an Ingress Controller to function.',
        difficulty: 'intermediate',
        tags: ['ingress', 'networking'],
      },
      {
        id: 'k8s-9',
        front: 'What is a StatefulSet and when do you use it?',
        back: 'StatefulSets manage stateful applications that require: stable unique network identifiers, stable persistent storage, and ordered graceful deployment/scaling. Each pod gets a persistent identity (pod-0, pod-1). Used for databases, message queues, and distributed systems.',
        difficulty: 'advanced',
        tags: ['statefulsets', 'stateful'],
      },
      {
        id: 'k8s-10',
        front: 'What is a Horizontal Pod Autoscaler (HPA)?',
        back: 'HPA automatically scales the number of pod replicas based on observed CPU utilization, memory usage, or custom metrics. It periodically checks metrics and adjusts the replica count between configured min and max values.',
        codeSnippet: 'apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nspec:\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          averageUtilization: 70',
        difficulty: 'intermediate',
        tags: ['autoscaling'],
      },
    ],
  },
  {
    id: 'system-design',
    title: 'System Design',
    description: 'Scalability, distributed systems, caching, and architecture patterns.',
    icon: 'Boxes',
    gradient: 'from-purple-500 to-pink-600',
    category: 'Architecture',
    cards: [
      {
        id: 'sd-1',
        front: 'What is horizontal scaling vs vertical scaling?',
        back: 'Vertical scaling (scale up): add more CPU/RAM to a single machine. Horizontal scaling (scale out): add more machines. Horizontal scaling is preferred for large systems because it offers better fault tolerance and theoretically unlimited capacity, but adds complexity (load balancing, data consistency).',
        difficulty: 'beginner',
        tags: ['scalability'],
      },
      {
        id: 'sd-2',
        front: 'Explain the CAP theorem.',
        back: 'In a distributed system, you can only guarantee two of three: Consistency (all nodes see the same data), Availability (every request gets a response), Partition tolerance (system works despite network failures). Since partitions are inevitable, you choose between CP (strong consistency) or AP (high availability).',
        difficulty: 'intermediate',
        tags: ['distributed-systems', 'theory'],
      },
      {
        id: 'sd-3',
        front: 'What is a CDN and how does it improve performance?',
        back: 'A Content Delivery Network distributes content across geographically distributed edge servers. It reduces latency by serving content from the nearest edge, decreases origin server load, provides DDoS protection, and improves availability through redundancy.',
        difficulty: 'beginner',
        tags: ['cdn', 'performance'],
      },
      {
        id: 'sd-4',
        front: 'Explain the difference between SQL and NoSQL databases.',
        back: 'SQL: relational, ACID-compliant, fixed schema, strong consistency, good for complex queries/joins. NoSQL: flexible schema, horizontally scalable, eventual consistency (typically), various models (document, key-value, column, graph). Choose based on data structure, scale, and consistency needs.',
        difficulty: 'beginner',
        tags: ['databases'],
      },
      {
        id: 'sd-5',
        front: 'What is a message queue and when should you use one?',
        back: 'A message queue (Kafka, RabbitMQ, SQS) decouples producers from consumers via asynchronous message passing. Use for: async processing, load leveling (absorb traffic spikes), service decoupling, event-driven architectures, and reliable delivery with retries.',
        difficulty: 'intermediate',
        tags: ['messaging', 'async'],
      },
      {
        id: 'sd-6',
        front: 'Explain caching strategies: write-through, write-back, and cache-aside.',
        back: 'Cache-aside: app checks cache first, loads from DB on miss, writes to cache. Write-through: writes go to cache AND DB simultaneously. Write-back: writes go to cache only, DB updated asynchronously (risk of data loss). Cache-aside is most common for read-heavy workloads.',
        difficulty: 'intermediate',
        tags: ['caching'],
      },
      {
        id: 'sd-7',
        front: 'What is consistent hashing and why is it used?',
        back: 'Consistent hashing distributes data across nodes using a hash ring. When a node is added/removed, only K/N keys need to be remapped (K=keys, N=nodes), vs. nearly all keys with simple modulo hashing. Used in distributed caches, databases, and load balancers.',
        difficulty: 'advanced',
        tags: ['distributed-systems', 'hashing'],
      },
      {
        id: 'sd-8',
        front: 'What is a rate limiter and what algorithms are commonly used?',
        back: 'A rate limiter controls the number of requests a client can make. Algorithms: Token Bucket (smooth, allows bursts), Leaky Bucket (constant rate), Fixed Window Counter (simple, boundary burst issue), Sliding Window Log (precise, memory-heavy), Sliding Window Counter (balanced).',
        difficulty: 'intermediate',
        tags: ['rate-limiting', 'api'],
      },
      {
        id: 'sd-9',
        front: 'Explain microservices vs monolith architecture.',
        back: 'Monolith: single deployable unit, simpler to develop/test/deploy initially, harder to scale specific components. Microservices: independently deployable services, better scalability and team autonomy, but adds complexity (networking, data consistency, observability). Start monolith, extract services when needed.',
        difficulty: 'intermediate',
        tags: ['architecture'],
      },
      {
        id: 'sd-10',
        front: 'What is database sharding and what are its trade-offs?',
        back: 'Sharding horizontally partitions data across multiple database instances using a shard key. Benefits: horizontal scalability, reduced query load per shard. Trade-offs: cross-shard queries are expensive, rebalancing is complex, some queries become impossible, and it adds operational complexity.',
        difficulty: 'advanced',
        tags: ['databases', 'scalability'],
      },
    ],
  },
  {
    id: 'nodejs',
    title: 'Node.js',
    description: 'Event loop, streams, clustering, error handling, and best practices.',
    icon: 'Server',
    gradient: 'from-green-500 to-emerald-600',
    category: 'Backend',
    cards: [
      {
        id: 'node-1',
        front: 'Explain the Node.js event loop and its phases.',
        back: 'The event loop processes async callbacks in phases: Timers (setTimeout/setInterval) → Pending callbacks (I/O) → Idle/Prepare → Poll (new I/O events) → Check (setImmediate) → Close callbacks. Each phase has a FIFO queue. process.nextTick runs between phases.',
        difficulty: 'intermediate',
        tags: ['event-loop', 'fundamentals'],
      },
      {
        id: 'node-2',
        front: 'What is the difference between process.nextTick() and setImmediate()?',
        back: 'process.nextTick() executes after the current operation completes, before the event loop continues—it can starve I/O if called recursively. setImmediate() executes in the check phase of the next event loop iteration. Prefer setImmediate() for deferring work.',
        difficulty: 'intermediate',
        tags: ['event-loop', 'async'],
      },
      {
        id: 'node-3',
        front: 'What are Node.js Streams and their types?',
        back: 'Streams process data piece-by-piece without loading everything into memory. Types: Readable (fs.createReadStream), Writable (fs.createWriteStream), Duplex (net.Socket—both read and write), Transform (zlib.createGzip—modify data while passing through).',
        difficulty: 'intermediate',
        tags: ['streams'],
      },
      {
        id: 'node-4',
        front: 'How does the cluster module work in Node.js?',
        back: 'The cluster module forks the main process into multiple worker processes, each running on a separate CPU core. The master process manages workers and distributes incoming connections. This enables utilizing all CPU cores since Node.js is single-threaded.',
        codeSnippet: 'if (cluster.isPrimary) {\n  for (let i = 0; i < os.cpus().length; i++)\n    cluster.fork();\n} else {\n  http.createServer(handler).listen(3000);\n}',
        difficulty: 'intermediate',
        tags: ['cluster', 'performance'],
      },
      {
        id: 'node-5',
        front: 'What is the difference between CommonJS and ES Modules?',
        back: 'CommonJS: require()/module.exports, synchronous loading, dynamic imports possible, default in Node. ES Modules: import/export, async loading, static analysis enables tree-shaking, must use .mjs or "type":"module". ESM is the future standard; CJS is legacy.',
        difficulty: 'beginner',
        tags: ['modules'],
      },
      {
        id: 'node-6',
        front: 'How should you handle errors in Node.js?',
        back: 'Sync: try/catch. Async callbacks: error-first pattern (err, data). Promises: .catch() or try/catch with async/await. Streams: listen for "error" event. Global: process.on("uncaughtException") and process.on("unhandledRejection"). Never swallow errors silently.',
        difficulty: 'beginner',
        tags: ['error-handling'],
      },
      {
        id: 'node-7',
        front: 'What is the purpose of Worker Threads?',
        back: 'Worker Threads run JavaScript in parallel threads, unlike cluster (separate processes). They share memory via SharedArrayBuffer and are ideal for CPU-intensive tasks (image processing, crypto) without blocking the event loop. Not needed for I/O-bound work.',
        difficulty: 'advanced',
        tags: ['worker-threads', 'performance'],
      },
      {
        id: 'node-8',
        front: 'What is middleware in Express.js?',
        back: 'Middleware functions have access to req, res, and next(). They execute in order and can modify request/response, end the cycle, or call next() to pass control. Types: application-level, router-level, error-handling (4 args), built-in, third-party.',
        codeSnippet: 'app.use((req, res, next) => {\n  console.log(`${req.method} ${req.url}`);\n  next();\n});',
        difficulty: 'beginner',
        tags: ['express', 'middleware'],
      },
      {
        id: 'node-9',
        front: 'What is backpressure in Node.js streams?',
        back: 'Backpressure occurs when data is written faster than it can be consumed. The writable stream\'s .write() returns false when its internal buffer is full, signaling the producer to pause. The "drain" event signals it\'s safe to resume. pipe() handles this automatically.',
        difficulty: 'advanced',
        tags: ['streams', 'performance'],
      },
      {
        id: 'node-10',
        front: 'What is the N+1 query problem and how do you solve it?',
        back: 'N+1 occurs when you fetch N items then make 1 additional query per item (e.g., fetching posts then each post\'s author separately). Solutions: JOIN queries, eager loading (include/populate), DataLoader pattern (batching + caching), or query builders with relation loading.',
        difficulty: 'intermediate',
        tags: ['databases', 'performance'],
      },
    ],
  },
  {
    id: 'sql-databases',
    title: 'SQL & Databases',
    description: 'SQL queries, indexing, transactions, normalization, and optimization.',
    icon: 'Database',
    gradient: 'from-amber-500 to-orange-600',
    category: 'Backend',
    cards: [
      {
        id: 'sql-1',
        front: 'What are the different types of SQL JOINs?',
        back: 'INNER JOIN: matching rows in both tables. LEFT JOIN: all rows from left + matching right. RIGHT JOIN: all rows from right + matching left. FULL OUTER JOIN: all rows from both tables. CROSS JOIN: cartesian product. SELF JOIN: table joined with itself.',
        difficulty: 'beginner',
        tags: ['joins', 'fundamentals'],
      },
      {
        id: 'sql-2',
        front: 'Explain database indexes and their trade-offs.',
        back: 'Indexes are data structures (typically B-trees) that speed up data retrieval. Trade-offs: faster reads but slower writes (index must be updated), additional storage space. Create indexes on frequently queried columns, foreign keys, and WHERE/ORDER BY columns.',
        difficulty: 'intermediate',
        tags: ['indexes', 'performance'],
      },
      {
        id: 'sql-3',
        front: 'What are ACID properties in database transactions?',
        back: 'Atomicity: all operations succeed or all fail. Consistency: transaction brings DB from one valid state to another. Isolation: concurrent transactions don\'t interfere. Durability: committed data survives system failures. These guarantee reliable transaction processing.',
        difficulty: 'beginner',
        tags: ['transactions', 'acid'],
      },
      {
        id: 'sql-4',
        front: 'Explain database normalization forms (1NF through 3NF).',
        back: '1NF: atomic values only, no repeating groups. 2NF: meets 1NF + no partial dependencies (all non-key columns depend on the entire primary key). 3NF: meets 2NF + no transitive dependencies (non-key columns don\'t depend on other non-key columns).',
        difficulty: 'intermediate',
        tags: ['normalization', 'design'],
      },
      {
        id: 'sql-5',
        front: 'What is the difference between WHERE and HAVING?',
        back: 'WHERE filters rows before grouping (cannot use aggregate functions). HAVING filters groups after GROUP BY (can use aggregates). Use WHERE to reduce rows before aggregation, HAVING to filter aggregated results.',
        codeSnippet: 'SELECT dept, COUNT(*) as cnt\nFROM employees\nWHERE active = true       -- filters rows\nGROUP BY dept\nHAVING COUNT(*) > 5;      -- filters groups',
        difficulty: 'beginner',
        tags: ['sql', 'aggregation'],
      },
      {
        id: 'sql-6',
        front: 'What are database transaction isolation levels?',
        back: 'READ UNCOMMITTED: can see uncommitted changes (dirty reads). READ COMMITTED: only sees committed data. REPEATABLE READ: same query returns same results within a transaction. SERIALIZABLE: full isolation, transactions appear sequential. Higher isolation = lower concurrency.',
        difficulty: 'advanced',
        tags: ['transactions', 'isolation'],
      },
      {
        id: 'sql-7',
        front: 'What is a deadlock and how do you prevent it?',
        back: 'A deadlock occurs when two transactions each hold a lock the other needs. Prevention: always acquire locks in the same order, keep transactions short, use lower isolation levels when possible, implement timeout-based deadlock detection.',
        difficulty: 'intermediate',
        tags: ['concurrency', 'locks'],
      },
      {
        id: 'sql-8',
        front: 'Explain the difference between UNION and UNION ALL.',
        back: 'UNION combines results from two queries and removes duplicate rows (requires sorting/hashing). UNION ALL combines results without removing duplicates, making it faster. Use UNION ALL when you know there are no duplicates or duplicates are acceptable.',
        difficulty: 'beginner',
        tags: ['sql', 'operators'],
      },
      {
        id: 'sql-9',
        front: 'What is a window function and when would you use one?',
        back: 'Window functions perform calculations across a set of rows related to the current row without collapsing them (unlike GROUP BY). They use OVER() to define the window. Common: ROW_NUMBER(), RANK(), LAG(), LEAD(), SUM() OVER(). Used for running totals, rankings, and comparisons.',
        codeSnippet: 'SELECT name, salary,\n  RANK() OVER (ORDER BY salary DESC) as rank,\n  AVG(salary) OVER () as avg_salary\nFROM employees;',
        difficulty: 'intermediate',
        tags: ['window-functions', 'advanced-sql'],
      },
      {
        id: 'sql-10',
        front: 'What is query execution plan and how do you use EXPLAIN?',
        back: 'An execution plan shows how the database engine will execute a query: which indexes it uses, join algorithms, sort methods, and estimated costs. EXPLAIN (or EXPLAIN ANALYZE) reveals this plan. Use it to identify full table scans, missing indexes, and inefficient joins.',
        difficulty: 'intermediate',
        tags: ['performance', 'optimization'],
      },
    ],
  },
  {
    id: 'git-cicd',
    title: 'Git & CI/CD',
    description: 'Git workflows, branching strategies, CI/CD pipelines, and deployment.',
    icon: 'GitBranch',
    gradient: 'from-rose-500 to-red-600',
    category: 'DevOps',
    cards: [
      {
        id: 'git-1',
        front: 'What is the difference between git merge and git rebase?',
        back: 'Merge creates a new commit that combines two branches, preserving history. Rebase replays commits on top of another branch, creating a linear history. Merge is safer for shared branches; rebase keeps history clean but rewrites commits (never rebase published branches).',
        difficulty: 'beginner',
        tags: ['git', 'branching'],
      },
      {
        id: 'git-2',
        front: 'Explain the Git Flow branching strategy.',
        back: 'Git Flow uses: main (production), develop (integration), feature/* (new features), release/* (prepare releases), hotfix/* (emergency fixes). Features branch from develop, releases branch from develop and merge to both main and develop. Suited for versioned releases.',
        difficulty: 'intermediate',
        tags: ['git', 'workflow'],
      },
      {
        id: 'git-3',
        front: 'What is git cherry-pick and when do you use it?',
        back: 'Cherry-pick applies a specific commit from one branch onto another. Use it to backport bug fixes to release branches, selectively apply changes without merging entire branches, or recover specific commits from abandoned branches.',
        codeSnippet: 'git cherry-pick abc123\n# Apply commit abc123 to current branch',
        difficulty: 'intermediate',
        tags: ['git', 'commands'],
      },
      {
        id: 'git-4',
        front: 'What is a CI/CD pipeline?',
        back: 'CI (Continuous Integration): automatically build and test code on every push. CD (Continuous Delivery): automatically prepare releases for deployment. CD (Continuous Deployment): automatically deploy to production. The pipeline: code push → build → test → deploy.',
        difficulty: 'beginner',
        tags: ['cicd', 'fundamentals'],
      },
      {
        id: 'git-5',
        front: 'What is the difference between git reset, git revert, and git checkout?',
        back: 'reset: moves HEAD and optionally changes staging/working directory (rewrites history). revert: creates a new commit that undoes a previous commit (safe for shared branches). checkout: switches branches or restores files (doesn\'t modify history).',
        difficulty: 'intermediate',
        tags: ['git', 'commands'],
      },
      {
        id: 'git-6',
        front: 'What are GitHub Actions and how do workflows work?',
        back: 'GitHub Actions is a CI/CD platform built into GitHub. Workflows are YAML files in .github/workflows/ triggered by events (push, PR, schedule). Each workflow has jobs that run on runners, and jobs contain steps that execute actions or shell commands.',
        codeSnippet: 'on: [push]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - run: npm ci\n      - run: npm test',
        difficulty: 'beginner',
        tags: ['github-actions', 'cicd'],
      },
      {
        id: 'git-7',
        front: 'What is trunk-based development?',
        back: 'Developers commit directly to a single branch (main/trunk) or use short-lived feature branches (<1 day). Relies on feature flags, comprehensive CI, and small incremental changes. Reduces merge conflicts and enables continuous deployment. Preferred by high-performing teams.',
        difficulty: 'intermediate',
        tags: ['workflow', 'branching'],
      },
      {
        id: 'git-8',
        front: 'Explain blue-green deployment strategy.',
        back: 'Two identical production environments: Blue (current) and Green (new). Deploy to Green, test it, then switch traffic from Blue to Green. If issues arise, instantly roll back by switching traffic back. Provides zero-downtime deployments with instant rollback.',
        difficulty: 'intermediate',
        tags: ['deployment', 'strategies'],
      },
      {
        id: 'git-9',
        front: 'What is git stash and when would you use it?',
        back: 'git stash temporarily shelves uncommitted changes so you can work on something else. Changes are saved to a stack and can be reapplied later. Use it when you need to switch branches but aren\'t ready to commit, or to clean your working directory temporarily.',
        codeSnippet: 'git stash          # save changes\ngit stash list     # see stashed items\ngit stash pop      # reapply latest\ngit stash drop     # discard latest',
        difficulty: 'beginner',
        tags: ['git', 'commands'],
      },
      {
        id: 'git-10',
        front: 'What is canary deployment?',
        back: 'Route a small percentage of traffic (e.g., 5%) to the new version while the majority continues using the old version. Monitor error rates and performance metrics. Gradually increase traffic to the new version if healthy. Reduces risk by limiting blast radius of bad deployments.',
        difficulty: 'intermediate',
        tags: ['deployment', 'strategies'],
      },
    ],
  },
];
