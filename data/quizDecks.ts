import { QuizDeck } from '../types';

export const quizDecks: QuizDeck[] = [
  // ─── 1. React ──────────────────────────────────────────────────────────────
  {
    id: 'react',
    title: 'React',
    description: 'Core concepts, hooks, state management, and performance patterns.',
    icon: 'Atom',
    gradient: 'from-cyan-500 to-blue-600',
    category: 'Frontend',
    questions: [
      {
        id: 'react-q1',
        question: 'What does the useState hook return?',
        options: [
          { id: 'react-q1-a', text: 'A single state value' },
          { id: 'react-q1-b', text: 'An array with the state value and a setter function' },
          { id: 'react-q1-c', text: 'An object with get and set methods' },
          { id: 'react-q1-d', text: 'A proxy object that tracks mutations' },
        ],
        correctOptionId: 'react-q1-b',
        explanation: 'useState returns an array with exactly two elements: the current state value and a function to update it. This convention allows you to use array destructuring to name them freely, e.g. const [count, setCount] = useState(0).',
        difficulty: 'beginner',
        tags: ['hooks', 'state'],
      },
      {
        id: 'react-q2',
        question: 'Which of the following is NOT a rule of React Hooks?',
        options: [
          { id: 'react-q2-a', text: 'Only call hooks at the top level' },
          { id: 'react-q2-b', text: 'Only call hooks from React functions' },
          { id: 'react-q2-c', text: 'Hooks must return a cleanup function' },
          { id: 'react-q2-d', text: 'Do not call hooks inside loops or conditions' },
        ],
        correctOptionId: 'react-q2-c',
        explanation: 'Hooks do not need to return a cleanup function. While useEffect can optionally return one, this is not a rule of hooks. The actual rules are: call hooks only at the top level and only from React function components or custom hooks.',
        difficulty: 'beginner',
        tags: ['hooks', 'rules'],
      },
      {
        id: 'react-q3',
        question: 'What will this component render on the second click of the button?',
        codeSnippet: 'function Counter() {\n  const [count, setCount] = useState(0);\n  const handleClick = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n  };\n  return <button onClick={handleClick}>{count}</button>;\n}',
        options: [
          { id: 'react-q3-a', text: '2' },
          { id: 'react-q3-b', text: '3' },
          { id: 'react-q3-c', text: '4' },
          { id: 'react-q3-d', text: '1' },
        ],
        correctOptionId: 'react-q3-a',
        explanation: 'Because both setCount calls use the stale `count` value from the current closure, they each compute count + 1 from the same base. After the first click count goes to 1, after the second click it goes to 2. To batch correctly you must use the updater form: setCount(c => c + 1).',
        difficulty: 'intermediate',
        tags: ['hooks', 'state', 'closures'],
      },
      {
        id: 'react-q4',
        question: 'What is the primary purpose of React.memo?',
        options: [
          { id: 'react-q4-a', text: 'To memoize expensive computations inside a component' },
          { id: 'react-q4-b', text: 'To prevent re-renders when props have not changed' },
          { id: 'react-q4-c', text: 'To cache API responses between renders' },
          { id: 'react-q4-d', text: 'To persist state across page navigations' },
        ],
        correctOptionId: 'react-q4-b',
        explanation: 'React.memo is a higher-order component that performs a shallow comparison of props. If the props are unchanged it skips re-rendering the wrapped component entirely. For memoizing computations, useMemo is the correct hook.',
        difficulty: 'intermediate',
        tags: ['performance', 'memoization'],
      },
      {
        id: 'react-q5',
        question: 'What happens when you pass an empty dependency array [] to useEffect?',
        options: [
          { id: 'react-q5-a', text: 'The effect runs on every render' },
          { id: 'react-q5-b', text: 'The effect never runs' },
          { id: 'react-q5-c', text: 'The effect runs only once after the initial render' },
          { id: 'react-q5-d', text: 'The effect runs only when the component unmounts' },
        ],
        correctOptionId: 'react-q5-c',
        explanation: 'An empty dependency array tells React the effect has no dependencies, so it only needs to run after the first render and its cleanup runs on unmount. This is the React equivalent of componentDidMount for side effects.',
        difficulty: 'beginner',
        tags: ['hooks', 'effects'],
      },
      {
        id: 'react-q6',
        question: 'What is the output of this custom hook usage?',
        codeSnippet: 'function useToggle(initial = false) {\n  const [value, setValue] = useState(initial);\n  const toggle = useCallback(() => setValue(v => !v), []);\n  return [value, toggle] as const;\n}\n\nfunction App() {\n  const [on, toggle] = useToggle(true);\n  return <span>{String(on)}</span>; // initial render?',
        options: [
          { id: 'react-q6-a', text: '"false"' },
          { id: 'react-q6-b', text: '"true"' },
          { id: 'react-q6-c', text: 'undefined' },
          { id: 'react-q6-d', text: '"on"' },
        ],
        correctOptionId: 'react-q6-b',
        explanation: 'The custom hook initializes state with the argument `true`. On the initial render no toggle has been called, so `on` is `true` and `String(true)` outputs "true". The `as const` ensures TypeScript infers a tuple type.',
        difficulty: 'intermediate',
        tags: ['hooks', 'custom-hooks'],
      },
      {
        id: 'react-q7',
        question: 'In React\'s Concurrent Mode, what does useTransition allow you to do?',
        options: [
          { id: 'react-q7-a', text: 'Animate component mount/unmount transitions' },
          { id: 'react-q7-b', text: 'Mark state updates as non-urgent so the UI stays responsive' },
          { id: 'react-q7-c', text: 'Transition between different routing pages' },
          { id: 'react-q7-d', text: 'Defer server-side rendering to the client' },
        ],
        correctOptionId: 'react-q7-b',
        explanation: 'useTransition returns an isPending flag and a startTransition function that lets you mark a state update as non-urgent. React can interrupt the transition render to handle more urgent updates (like user input), keeping the interface responsive.',
        difficulty: 'advanced',
        tags: ['concurrent-mode', 'performance'],
      },
      {
        id: 'react-q8',
        question: 'What problem does the React key prop solve during list reconciliation?',
        options: [
          { id: 'react-q8-a', text: 'It speeds up the rendering of large lists by skipping unchanged items' },
          { id: 'react-q8-b', text: 'It uniquely identifies elements so React can match them across re-renders' },
          { id: 'react-q8-c', text: 'It encrypts sensitive data in the DOM' },
          { id: 'react-q8-d', text: 'It determines the CSS z-index of list items' },
        ],
        correctOptionId: 'react-q8-b',
        explanation: 'Keys give React a stable identity for each element in a list. During reconciliation React uses keys to determine which items changed, were added, or were removed, preventing incorrect state preservation or DOM node reuse.',
        difficulty: 'intermediate',
        tags: ['reconciliation', 'lists'],
      },
      {
        id: 'react-q9',
        question: 'Which pattern is used to share cross-cutting logic between components before hooks existed?',
        options: [
          { id: 'react-q9-a', text: 'Context API' },
          { id: 'react-q9-b', text: 'Higher-Order Components (HOCs) and Render Props' },
          { id: 'react-q9-c', text: 'Global event emitters' },
          { id: 'react-q9-d', text: 'Service workers' },
        ],
        correctOptionId: 'react-q9-b',
        explanation: 'Before hooks, Higher-Order Components and Render Props were the primary patterns for sharing stateful logic between components. HOCs wrap a component to inject props, while render props use a function child. Hooks replaced both with a simpler composition model.',
        difficulty: 'advanced',
        tags: ['patterns', 'composition'],
      },
      {
        id: 'react-q10',
        question: 'What is the correct way to avoid a stale closure when updating state based on its previous value inside an event handler?',
        codeSnippet: '// Which approach is correct?\n// A: setItems([...items, newItem])\n// B: setItems(prev => [...prev, newItem])',
        options: [
          { id: 'react-q10-a', text: 'Approach A because spread syntax always creates a new reference' },
          { id: 'react-q10-b', text: 'Approach B because the updater function receives the latest state' },
          { id: 'react-q10-c', text: 'Both are identical in behavior' },
          { id: 'react-q10-d', text: 'Neither; you must use useReducer instead' },
        ],
        correctOptionId: 'react-q10-b',
        explanation: 'The functional updater form (prev => ...) always receives the most recent state value, avoiding stale closures. Approach A captures `items` from the closure at render time, which can be outdated if multiple updates are batched or fired in quick succession.',
        difficulty: 'advanced',
        tags: ['hooks', 'closures', 'state'],
      },
    ],
  },

  // ─── 2. TypeScript ─────────────────────────────────────────────────────────
  {
    id: 'typescript',
    title: 'TypeScript',
    description: 'Type system, generics, utility types, and advanced patterns.',
    icon: 'FileCode2',
    gradient: 'from-blue-500 to-indigo-600',
    category: 'Frontend',
    questions: [
      {
        id: 'typescript-q1',
        question: 'What is the difference between `interface` and `type` in TypeScript?',
        options: [
          { id: 'typescript-q1-a', text: 'Interfaces can be extended with declaration merging; type aliases cannot' },
          { id: 'typescript-q1-b', text: 'Type aliases support generics but interfaces do not' },
          { id: 'typescript-q1-c', text: 'They are completely interchangeable in all cases' },
          { id: 'typescript-q1-d', text: 'Interfaces can only describe objects; type aliases can only describe primitives' },
        ],
        correctOptionId: 'typescript-q1-a',
        explanation: 'The key difference is that interfaces support declaration merging, meaning you can declare the same interface multiple times and TypeScript will merge them. Type aliases are closed after creation. Both support generics and can describe objects, but type aliases can also describe unions and primitives.',
        difficulty: 'beginner',
        tags: ['types', 'interfaces'],
      },
      {
        id: 'typescript-q2',
        question: 'What does the `unknown` type represent and how does it differ from `any`?',
        options: [
          { id: 'typescript-q2-a', text: 'They are the same; `unknown` is just an alias for `any`' },
          { id: 'typescript-q2-b', text: '`unknown` is the type-safe counterpart of `any` that requires type narrowing before use' },
          { id: 'typescript-q2-c', text: '`unknown` represents null or undefined only' },
          { id: 'typescript-q2-d', text: '`unknown` can only be assigned to variables of type `any`' },
        ],
        correctOptionId: 'typescript-q2-b',
        explanation: 'While `any` disables type checking entirely, `unknown` accepts any value but requires you to narrow the type (via typeof, instanceof, or type guards) before performing operations on it. This makes `unknown` the type-safe top type.',
        difficulty: 'beginner',
        tags: ['types', 'type-safety'],
      },
      {
        id: 'typescript-q3',
        question: 'What is the inferred type of `result`?',
        codeSnippet: 'function wrap<T>(value: T): { data: T } {\n  return { data: value };\n}\nconst result = wrap("hello");',
        options: [
          { id: 'typescript-q3-a', text: '{ data: any }' },
          { id: 'typescript-q3-b', text: '{ data: unknown }' },
          { id: 'typescript-q3-c', text: '{ data: string }' },
          { id: 'typescript-q3-d', text: '{ data: "hello" }' },
        ],
        correctOptionId: 'typescript-q3-c',
        explanation: 'TypeScript infers the generic parameter T as `string` from the argument "hello". The return type is therefore { data: string }. TypeScript widens string literals to `string` by default in this position unless `as const` is used.',
        difficulty: 'intermediate',
        tags: ['generics', 'inference'],
      },
      {
        id: 'typescript-q4',
        question: 'Which utility type creates a new type with all properties of T set to optional?',
        options: [
          { id: 'typescript-q4-a', text: 'Required<T>' },
          { id: 'typescript-q4-b', text: 'Partial<T>' },
          { id: 'typescript-q4-c', text: 'Pick<T, K>' },
          { id: 'typescript-q4-d', text: 'Readonly<T>' },
        ],
        correctOptionId: 'typescript-q4-b',
        explanation: 'Partial<T> constructs a type with all properties of T set to optional. This is commonly used for update functions where you only need to provide the fields you want to change. Required<T> does the opposite, making all properties required.',
        difficulty: 'beginner',
        tags: ['utility-types'],
      },
      {
        id: 'typescript-q5',
        question: 'What does this conditional type evaluate to?',
        codeSnippet: 'type IsString<T> = T extends string ? "yes" : "no";\ntype A = IsString<"hello">;\ntype B = IsString<42>;',
        options: [
          { id: 'typescript-q5-a', text: 'A = "yes", B = "yes"' },
          { id: 'typescript-q5-b', text: 'A = "yes", B = "no"' },
          { id: 'typescript-q5-c', text: 'A = "no", B = "no"' },
          { id: 'typescript-q5-d', text: 'A = string, B = number' },
        ],
        correctOptionId: 'typescript-q5-b',
        explanation: 'Conditional types use the `extends` keyword to check assignability. "hello" extends string evaluates to true so A is "yes". 42 does not extend string so B is "no". This pattern is foundational for advanced type-level programming.',
        difficulty: 'intermediate',
        tags: ['conditional-types', 'generics'],
      },
      {
        id: 'typescript-q6',
        question: 'What is a discriminated union in TypeScript?',
        codeSnippet: 'type Shape =\n  | { kind: "circle"; radius: number }\n  | { kind: "square"; side: number };',
        options: [
          { id: 'typescript-q6-a', text: 'A union where each member has a common literal property that TypeScript can narrow on' },
          { id: 'typescript-q6-b', text: 'A union that only contains primitive types' },
          { id: 'typescript-q6-c', text: 'A type that discriminates between classes using instanceof' },
          { id: 'typescript-q6-d', text: 'A union that automatically excludes null and undefined' },
        ],
        correctOptionId: 'typescript-q6-a',
        explanation: 'A discriminated union (or tagged union) is a union type where each member shares a common property with a literal type (the discriminant). TypeScript uses this property in switch or if statements to narrow the type, giving you access to member-specific properties.',
        difficulty: 'intermediate',
        tags: ['unions', 'narrowing'],
      },
      {
        id: 'typescript-q7',
        question: 'What does the `infer` keyword do in TypeScript?',
        codeSnippet: 'type ReturnOf<T> = T extends (...args: any[]) => infer R ? R : never;',
        options: [
          { id: 'typescript-q7-a', text: 'It declares a new generic parameter' },
          { id: 'typescript-q7-b', text: 'It infers a type variable within a conditional type\'s extends clause' },
          { id: 'typescript-q7-c', text: 'It enforces a constraint on a generic type' },
          { id: 'typescript-q7-d', text: 'It makes TypeScript skip type checking for the inferred position' },
        ],
        correctOptionId: 'typescript-q7-b',
        explanation: 'The `infer` keyword lets you declare a type variable within the extends clause of a conditional type. TypeScript will infer the actual type and bind it to the variable (R in this case). This is how built-in utility types like ReturnType<T> are implemented.',
        difficulty: 'advanced',
        tags: ['conditional-types', 'infer'],
      },
      {
        id: 'typescript-q8',
        question: 'What does `keyof` produce when applied to an interface?',
        codeSnippet: 'interface User {\n  id: number;\n  name: string;\n  email: string;\n}\ntype UserKeys = keyof User;',
        options: [
          { id: 'typescript-q8-a', text: '"id" | "name" | "email"' },
          { id: 'typescript-q8-b', text: 'number | string' },
          { id: 'typescript-q8-c', text: '["id", "name", "email"]' },
          { id: 'typescript-q8-d', text: 'string' },
        ],
        correctOptionId: 'typescript-q8-a',
        explanation: 'The `keyof` operator produces a union of string literal types representing the known public property names of the given type. For the User interface, it produces "id" | "name" | "email". This is commonly used with mapped types and generic constraints.',
        difficulty: 'intermediate',
        tags: ['keyof', 'utility-types'],
      },
      {
        id: 'typescript-q9',
        question: 'What is the purpose of the `never` type in TypeScript?',
        options: [
          { id: 'typescript-q9-a', text: 'It represents a value that is always null' },
          { id: 'typescript-q9-b', text: 'It represents the type of values that never occur, used for exhaustiveness checks and unreachable code' },
          { id: 'typescript-q9-c', text: 'It is equivalent to void' },
          { id: 'typescript-q9-d', text: 'It disables type checking for a variable' },
        ],
        correctOptionId: 'typescript-q9-b',
        explanation: 'The `never` type represents values that never occur. Functions that throw always or have infinite loops return `never`. It is also the result of impossible intersections and is used in exhaustiveness checks to ensure all union cases are handled in switch statements.',
        difficulty: 'advanced',
        tags: ['types', 'never'],
      },
      {
        id: 'typescript-q10',
        question: 'What does this mapped type produce?',
        codeSnippet: 'type Flags<T> = {\n  [K in keyof T]: boolean;\n};\ntype UserFlags = Flags<{ name: string; age: number }>;',
        options: [
          { id: 'typescript-q10-a', text: '{ name: string; age: number }' },
          { id: 'typescript-q10-b', text: '{ name: boolean; age: boolean }' },
          { id: 'typescript-q10-c', text: 'boolean' },
          { id: 'typescript-q10-d', text: '{ name: boolean } | { age: boolean }' },
        ],
        correctOptionId: 'typescript-q10-b',
        explanation: 'Mapped types iterate over the keys of another type using `in keyof`. The Flags type maps every property to boolean, preserving the key names. So UserFlags becomes { name: boolean; age: boolean }. This pattern is the basis for utility types like Readonly and Partial.',
        difficulty: 'advanced',
        tags: ['mapped-types', 'generics'],
      },
    ],
  },

  // ─── 3. Docker ─────────────────────────────────────────────────────────────
  {
    id: 'docker',
    title: 'Docker',
    description: 'Containers, images, networking, volumes, and best practices.',
    icon: 'Container',
    gradient: 'from-sky-500 to-cyan-600',
    category: 'DevOps',
    questions: [
      {
        id: 'docker-q1',
        question: 'What is the difference between a Docker image and a Docker container?',
        options: [
          { id: 'docker-q1-a', text: 'They are the same thing' },
          { id: 'docker-q1-b', text: 'An image is a read-only template; a container is a running instance of an image' },
          { id: 'docker-q1-c', text: 'A container is a read-only template; an image is a running instance' },
          { id: 'docker-q1-d', text: 'Images run on the host OS; containers run in VMs' },
        ],
        correctOptionId: 'docker-q1-b',
        explanation: 'A Docker image is a read-only template containing the application code, runtime, libraries, and dependencies. A container is a runnable instance of an image with its own writable layer. You can create many containers from a single image.',
        difficulty: 'beginner',
        tags: ['images', 'containers', 'fundamentals'],
      },
      {
        id: 'docker-q2',
        question: 'What does the COPY instruction do in a Dockerfile versus ADD?',
        options: [
          { id: 'docker-q2-a', text: 'They are identical in functionality' },
          { id: 'docker-q2-b', text: 'COPY only copies local files; ADD can also fetch URLs and extract tar archives' },
          { id: 'docker-q2-c', text: 'ADD only copies local files; COPY can fetch URLs' },
          { id: 'docker-q2-d', text: 'COPY works at build time; ADD works at runtime' },
        ],
        correctOptionId: 'docker-q2-b',
        explanation: 'COPY is the simpler instruction that copies files and directories from the build context into the image. ADD has extra features: it can download files from URLs and automatically extract recognized tar archives. Best practice is to use COPY unless you specifically need ADD\'s extra features.',
        difficulty: 'beginner',
        tags: ['dockerfile', 'instructions'],
      },
      {
        id: 'docker-q3',
        question: 'What is a multi-stage build in Docker?',
        codeSnippet: 'FROM node:18 AS builder\nWORKDIR /app\nCOPY . .\nRUN npm ci && npm run build\n\nFROM nginx:alpine\nCOPY --from=builder /app/dist /usr/share/nginx/html',
        options: [
          { id: 'docker-q3-a', text: 'Building multiple Docker images in parallel' },
          { id: 'docker-q3-b', text: 'Using multiple FROM instructions to create smaller final images by discarding build dependencies' },
          { id: 'docker-q3-c', text: 'Running multiple containers from one Dockerfile' },
          { id: 'docker-q3-d', text: 'A build that spans multiple Docker daemons' },
        ],
        correctOptionId: 'docker-q3-b',
        explanation: 'Multi-stage builds use multiple FROM statements in a single Dockerfile. Each FROM starts a new build stage. You can selectively copy artifacts from one stage to another, leaving behind build tools and intermediate files. This produces much smaller production images.',
        difficulty: 'intermediate',
        tags: ['multi-stage', 'optimization'],
      },
      {
        id: 'docker-q4',
        question: 'What is the difference between CMD and ENTRYPOINT in a Dockerfile?',
        options: [
          { id: 'docker-q4-a', text: 'CMD sets the default command that can be overridden; ENTRYPOINT sets the fixed executable' },
          { id: 'docker-q4-b', text: 'ENTRYPOINT can be overridden; CMD cannot' },
          { id: 'docker-q4-c', text: 'CMD runs at build time; ENTRYPOINT runs at container start' },
          { id: 'docker-q4-d', text: 'They are interchangeable' },
        ],
        correctOptionId: 'docker-q4-a',
        explanation: 'ENTRYPOINT configures the container to run as an executable and is harder to override (requires --entrypoint flag). CMD provides default arguments that can be easily overridden by passing arguments to docker run. They are often used together: ENTRYPOINT for the command, CMD for default arguments.',
        difficulty: 'intermediate',
        tags: ['dockerfile', 'entrypoint', 'cmd'],
      },
      {
        id: 'docker-q5',
        question: 'Which Docker network driver allows containers on different hosts to communicate?',
        options: [
          { id: 'docker-q5-a', text: 'bridge' },
          { id: 'docker-q5-b', text: 'host' },
          { id: 'docker-q5-c', text: 'overlay' },
          { id: 'docker-q5-d', text: 'none' },
        ],
        correctOptionId: 'docker-q5-c',
        explanation: 'The overlay network driver creates a distributed network across multiple Docker daemon hosts. It is used in Docker Swarm and Kubernetes to enable communication between containers on different physical or virtual machines. Bridge networks only work on a single host.',
        difficulty: 'intermediate',
        tags: ['networking', 'overlay'],
      },
      {
        id: 'docker-q6',
        question: 'What is the purpose of a .dockerignore file?',
        options: [
          { id: 'docker-q6-a', text: 'It lists images that should not be pulled' },
          { id: 'docker-q6-b', text: 'It excludes files and directories from the Docker build context' },
          { id: 'docker-q6-c', text: 'It specifies containers to ignore during docker-compose up' },
          { id: 'docker-q6-d', text: 'It prevents certain environment variables from being set' },
        ],
        correctOptionId: 'docker-q6-b',
        explanation: 'The .dockerignore file tells Docker which files and directories to exclude from the build context sent to the daemon. This speeds up builds, reduces image size, and prevents sensitive files like .env or node_modules from being accidentally included.',
        difficulty: 'beginner',
        tags: ['build-context', 'best-practices'],
      },
      {
        id: 'docker-q7',
        question: 'What is the difference between a named volume and a bind mount?',
        options: [
          { id: 'docker-q7-a', text: 'Named volumes are managed by Docker; bind mounts map to a specific host path' },
          { id: 'docker-q7-b', text: 'Bind mounts are managed by Docker; named volumes map to a specific host path' },
          { id: 'docker-q7-c', text: 'Named volumes only work on Linux; bind mounts work everywhere' },
          { id: 'docker-q7-d', text: 'There is no difference; they are aliases' },
        ],
        correctOptionId: 'docker-q7-a',
        explanation: 'Named volumes are created and managed by Docker, stored in Docker\'s storage directory, and are the recommended way to persist data. Bind mounts directly map a file or directory on the host machine into the container, giving you full control over the path but less portability.',
        difficulty: 'intermediate',
        tags: ['volumes', 'storage'],
      },
      {
        id: 'docker-q8',
        question: 'Why should you avoid running containers as root in production?',
        options: [
          { id: 'docker-q8-a', text: 'Root containers use more memory' },
          { id: 'docker-q8-b', text: 'A container escape vulnerability could grant the attacker root access to the host' },
          { id: 'docker-q8-c', text: 'Root containers cannot access the network' },
          { id: 'docker-q8-d', text: 'Docker does not support running as root' },
        ],
        correctOptionId: 'docker-q8-b',
        explanation: 'Running containers as root is a security risk because if an attacker exploits a container escape vulnerability, they could gain root access on the host machine. Best practice is to use the USER instruction in Dockerfiles to run as a non-root user, following the principle of least privilege.',
        difficulty: 'advanced',
        tags: ['security', 'best-practices'],
      },
      {
        id: 'docker-q9',
        question: 'What does `docker system prune -a` do?',
        options: [
          { id: 'docker-q9-a', text: 'Removes only stopped containers' },
          { id: 'docker-q9-b', text: 'Removes all unused containers, networks, images (including unused ones), and optionally volumes' },
          { id: 'docker-q9-c', text: 'Deletes the Docker daemon configuration' },
          { id: 'docker-q9-d', text: 'Reinstalls Docker from scratch' },
        ],
        correctOptionId: 'docker-q9-b',
        explanation: 'docker system prune -a removes all stopped containers, unused networks, dangling and unreferenced images, and build cache. The -a flag includes all unused images, not just dangling ones. Add --volumes to also remove unused volumes. This is useful for reclaiming disk space.',
        difficulty: 'advanced',
        tags: ['cleanup', 'commands'],
      },
      {
        id: 'docker-q10',
        question: 'What is the recommended best practice for layer caching in a Node.js Dockerfile?',
        codeSnippet: '# Which ordering is more cache-efficient?\n# Option A:\nCOPY . .\nRUN npm install\n\n# Option B:\nCOPY package*.json .\nRUN npm install\nCOPY . .',
        options: [
          { id: 'docker-q10-a', text: 'Option A, because it uses fewer layers' },
          { id: 'docker-q10-b', text: 'Option B, because npm install is cached when only source files change' },
          { id: 'docker-q10-c', text: 'Both are equivalent in caching behavior' },
          { id: 'docker-q10-d', text: 'Neither; you should use npm ci instead of npm install' },
        ],
        correctOptionId: 'docker-q10-b',
        explanation: 'Option B is the best practice. By copying package.json first and running npm install before copying the rest of the source code, Docker can cache the expensive dependency installation layer. Source code changes will not invalidate the npm install cache, significantly speeding up builds.',
        difficulty: 'advanced',
        tags: ['layer-caching', 'optimization', 'nodejs'],
      },
    ],
  },

  // ─── 4. Kubernetes ─────────────────────────────────────────────────────────
  {
    id: 'kubernetes',
    title: 'Kubernetes',
    description: 'Pods, services, deployments, scaling, and cluster management.',
    icon: 'Network',
    gradient: 'from-indigo-500 to-purple-600',
    category: 'DevOps',
    questions: [
      {
        id: 'kubernetes-q1',
        question: 'What is the smallest deployable unit in Kubernetes?',
        options: [
          { id: 'kubernetes-q1-a', text: 'Container' },
          { id: 'kubernetes-q1-b', text: 'Pod' },
          { id: 'kubernetes-q1-c', text: 'Node' },
          { id: 'kubernetes-q1-d', text: 'Deployment' },
        ],
        correctOptionId: 'kubernetes-q1-b',
        explanation: 'A Pod is the smallest deployable unit in Kubernetes. It represents one or more containers that share the same network namespace and storage volumes. While you typically run one container per pod, sidecar patterns use multiple containers in a single pod.',
        difficulty: 'beginner',
        tags: ['pods', 'fundamentals'],
      },
      {
        id: 'kubernetes-q2',
        question: 'What is the role of a Kubernetes Service?',
        options: [
          { id: 'kubernetes-q2-a', text: 'It monitors the health of nodes' },
          { id: 'kubernetes-q2-b', text: 'It provides a stable network endpoint to access a set of pods' },
          { id: 'kubernetes-q2-c', text: 'It builds container images' },
          { id: 'kubernetes-q2-d', text: 'It manages secrets and configuration' },
        ],
        correctOptionId: 'kubernetes-q2-b',
        explanation: 'A Kubernetes Service provides a stable IP address and DNS name to access a dynamic set of pods selected by labels. Since pods are ephemeral and their IPs change, Services abstract away this volatility and load-balance traffic across healthy pod instances.',
        difficulty: 'beginner',
        tags: ['services', 'networking'],
      },
      {
        id: 'kubernetes-q3',
        question: 'What does a Deployment controller manage?',
        options: [
          { id: 'kubernetes-q3-a', text: 'Persistent storage for pods' },
          { id: 'kubernetes-q3-b', text: 'Declarative updates and rollbacks for ReplicaSets and Pods' },
          { id: 'kubernetes-q3-c', text: 'Network policies between namespaces' },
          { id: 'kubernetes-q3-d', text: 'Cluster-wide DNS resolution' },
        ],
        correctOptionId: 'kubernetes-q3-b',
        explanation: 'A Deployment manages the lifecycle of ReplicaSets and their Pods. It enables declarative updates (rolling updates by default), automatic rollback on failure, and scaling. The Deployment controller ensures the desired state matches the actual state in the cluster.',
        difficulty: 'beginner',
        tags: ['deployments', 'controllers'],
      },
      {
        id: 'kubernetes-q4',
        question: 'What is the difference between a ConfigMap and a Secret in Kubernetes?',
        options: [
          { id: 'kubernetes-q4-a', text: 'ConfigMaps store non-sensitive config; Secrets store sensitive data with base64 encoding' },
          { id: 'kubernetes-q4-b', text: 'They are identical but Secrets are encrypted at rest by default' },
          { id: 'kubernetes-q4-c', text: 'ConfigMaps can only store files; Secrets can only store key-value pairs' },
          { id: 'kubernetes-q4-d', text: 'Secrets are for environment variables; ConfigMaps are for volumes only' },
        ],
        correctOptionId: 'kubernetes-q4-a',
        explanation: 'ConfigMaps store non-confidential configuration data as key-value pairs. Secrets are intended for sensitive data like passwords and tokens, stored as base64-encoded values. Note that base64 is not encryption; for actual encryption at rest you need to enable EncryptionConfiguration.',
        difficulty: 'intermediate',
        tags: ['configmaps', 'secrets'],
      },
      {
        id: 'kubernetes-q5',
        question: 'What type of Kubernetes Service exposes a pod externally using a cloud provider\'s load balancer?',
        options: [
          { id: 'kubernetes-q5-a', text: 'ClusterIP' },
          { id: 'kubernetes-q5-b', text: 'NodePort' },
          { id: 'kubernetes-q5-c', text: 'LoadBalancer' },
          { id: 'kubernetes-q5-d', text: 'ExternalName' },
        ],
        correctOptionId: 'kubernetes-q5-c',
        explanation: 'A LoadBalancer Service type provisions an external load balancer from the cloud provider (AWS ELB, GCP LB, etc.) and assigns it a public IP. ClusterIP is internal-only, NodePort exposes on each node\'s IP at a static port, and ExternalName maps to a DNS name.',
        difficulty: 'intermediate',
        tags: ['services', 'networking'],
      },
      {
        id: 'kubernetes-q6',
        question: 'What does a liveness probe do in Kubernetes?',
        codeSnippet: 'livenessProbe:\n  httpGet:\n    path: /healthz\n    port: 8080\n  initialDelaySeconds: 15\n  periodSeconds: 10',
        options: [
          { id: 'kubernetes-q6-a', text: 'Determines if the container is ready to accept traffic' },
          { id: 'kubernetes-q6-b', text: 'Checks if the container is still running and restarts it if the probe fails' },
          { id: 'kubernetes-q6-c', text: 'Monitors CPU usage and triggers autoscaling' },
          { id: 'kubernetes-q6-d', text: 'Validates the container image before deployment' },
        ],
        correctOptionId: 'kubernetes-q6-b',
        explanation: 'A liveness probe tells Kubernetes whether a container is still alive. If the probe fails repeatedly, the kubelet kills the container and restarts it. This is different from a readiness probe, which determines if the container is ready to serve traffic without restarting it.',
        difficulty: 'intermediate',
        tags: ['probes', 'health-checks'],
      },
      {
        id: 'kubernetes-q7',
        question: 'What is a StatefulSet used for?',
        options: [
          { id: 'kubernetes-q7-a', text: 'Running stateless microservices with rolling updates' },
          { id: 'kubernetes-q7-b', text: 'Managing stateful applications that require stable network identities and persistent storage' },
          { id: 'kubernetes-q7-c', text: 'Running one-time batch jobs that complete and terminate' },
          { id: 'kubernetes-q7-d', text: 'Scheduling cron-like tasks in the cluster' },
        ],
        correctOptionId: 'kubernetes-q7-b',
        explanation: 'StatefulSets manage stateful applications like databases that need stable, unique network identifiers, persistent storage, and ordered deployment/scaling. Unlike Deployments, pods in a StatefulSet have predictable names (e.g., mysql-0, mysql-1) and retain their storage across restarts.',
        difficulty: 'advanced',
        tags: ['statefulsets', 'stateful-apps'],
      },
      {
        id: 'kubernetes-q8',
        question: 'What is a Kubernetes Ingress resource?',
        options: [
          { id: 'kubernetes-q8-a', text: 'A firewall rule that blocks incoming traffic' },
          { id: 'kubernetes-q8-b', text: 'An API object that manages external HTTP/HTTPS access to services with routing rules' },
          { id: 'kubernetes-q8-c', text: 'A type of persistent volume for storing ingress logs' },
          { id: 'kubernetes-q8-d', text: 'A mechanism for pods to communicate with external databases' },
        ],
        correctOptionId: 'kubernetes-q8-b',
        explanation: 'An Ingress is an API object that manages external access to services, typically HTTP/HTTPS. It provides URL-based routing, SSL termination, and virtual hosting. An Ingress Controller (like nginx-ingress or traefik) must be running in the cluster to fulfill Ingress resources.',
        difficulty: 'intermediate',
        tags: ['ingress', 'networking'],
      },
      {
        id: 'kubernetes-q9',
        question: 'What is the purpose of Horizontal Pod Autoscaler (HPA)?',
        options: [
          { id: 'kubernetes-q9-a', text: 'It automatically adds more nodes to the cluster' },
          { id: 'kubernetes-q9-b', text: 'It scales the number of pod replicas based on observed metrics like CPU utilization' },
          { id: 'kubernetes-q9-c', text: 'It horizontally partitions data across pods' },
          { id: 'kubernetes-q9-d', text: 'It balances network traffic evenly across pods' },
        ],
        correctOptionId: 'kubernetes-q9-b',
        explanation: 'HPA automatically scales the number of pod replicas in a Deployment or ReplicaSet based on observed CPU/memory utilization or custom metrics. It periodically checks metrics and adjusts the replica count to match the target utilization. The Cluster Autoscaler, by contrast, adds or removes nodes.',
        difficulty: 'advanced',
        tags: ['autoscaling', 'hpa'],
      },
      {
        id: 'kubernetes-q10',
        question: 'What does a NetworkPolicy control in Kubernetes?',
        codeSnippet: 'apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-all\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  - Egress',
        options: [
          { id: 'kubernetes-q10-a', text: 'Which container images are allowed to run' },
          { id: 'kubernetes-q10-b', text: 'The amount of bandwidth allocated to each pod' },
          { id: 'kubernetes-q10-c', text: 'Which pods can communicate with each other through ingress and egress rules' },
          { id: 'kubernetes-q10-d', text: 'The DNS resolution order within the cluster' },
        ],
        correctOptionId: 'kubernetes-q10-c',
        explanation: 'NetworkPolicies are firewall rules for pods that control ingress (incoming) and egress (outgoing) traffic. The example above selects all pods (empty podSelector) and blocks all traffic since no ingress or egress rules are specified. A CNI plugin that supports NetworkPolicies (like Calico) is required.',
        difficulty: 'advanced',
        tags: ['network-policy', 'security'],
      },
    ],
  },

  // ─── 5. System Design ──────────────────────────────────────────────────────
  {
    id: 'system-design',
    title: 'System Design',
    description: 'Scalability, distributed systems, caching, and architectural patterns.',
    icon: 'Boxes',
    gradient: 'from-purple-500 to-pink-600',
    category: 'Architecture',
    questions: [
      {
        id: 'system-design-q1',
        question: 'What does CAP theorem state about distributed systems?',
        options: [
          { id: 'system-design-q1-a', text: 'A system can achieve Consistency, Availability, and Partition tolerance simultaneously' },
          { id: 'system-design-q1-b', text: 'A system can guarantee at most two of Consistency, Availability, and Partition tolerance' },
          { id: 'system-design-q1-c', text: 'Caching, Authentication, and Performance are the three pillars' },
          { id: 'system-design-q1-d', text: 'Capacity, Allocation, and Processing must be balanced' },
        ],
        correctOptionId: 'system-design-q1-b',
        explanation: 'The CAP theorem states that in the presence of a network partition, a distributed system must choose between Consistency (every read gets the most recent write) and Availability (every request gets a response). You cannot guarantee all three simultaneously when partitions occur.',
        difficulty: 'beginner',
        tags: ['cap-theorem', 'distributed-systems'],
      },
      {
        id: 'system-design-q2',
        question: 'What is the primary purpose of a load balancer?',
        options: [
          { id: 'system-design-q2-a', text: 'To encrypt all network traffic' },
          { id: 'system-design-q2-b', text: 'To distribute incoming traffic across multiple servers to improve reliability and throughput' },
          { id: 'system-design-q2-c', text: 'To compress response payloads for faster delivery' },
          { id: 'system-design-q2-d', text: 'To cache database queries in memory' },
        ],
        correctOptionId: 'system-design-q2-b',
        explanation: 'A load balancer distributes incoming network requests across multiple backend servers. This prevents any single server from becoming a bottleneck, improves fault tolerance (unhealthy servers are removed from the pool), and enables horizontal scaling by adding more servers.',
        difficulty: 'beginner',
        tags: ['load-balancing', 'scalability'],
      },
      {
        id: 'system-design-q3',
        question: 'What is the difference between horizontal and vertical scaling?',
        options: [
          { id: 'system-design-q3-a', text: 'Horizontal adds more machines; vertical adds more resources to existing machines' },
          { id: 'system-design-q3-b', text: 'Vertical adds more machines; horizontal adds more resources to existing machines' },
          { id: 'system-design-q3-c', text: 'Horizontal scaling is for databases only; vertical is for applications' },
          { id: 'system-design-q3-d', text: 'They are the same but for different cloud providers' },
        ],
        correctOptionId: 'system-design-q3-a',
        explanation: 'Horizontal scaling (scaling out) adds more machines to handle load, distributing work across them. Vertical scaling (scaling up) increases the power of existing machines (more CPU, RAM, etc.). Horizontal scaling provides better fault tolerance and is generally preferred for large-scale systems.',
        difficulty: 'beginner',
        tags: ['scalability', 'fundamentals'],
      },
      {
        id: 'system-design-q4',
        question: 'In a caching strategy, what is the "cache-aside" (lazy loading) pattern?',
        options: [
          { id: 'system-design-q4-a', text: 'The application writes to cache first, then to the database' },
          { id: 'system-design-q4-b', text: 'The application checks the cache; on miss, it reads from the database and populates the cache' },
          { id: 'system-design-q4-c', text: 'The database automatically pushes updates to the cache' },
          { id: 'system-design-q4-d', text: 'The cache pre-loads all database records at startup' },
        ],
        correctOptionId: 'system-design-q4-b',
        explanation: 'In cache-aside, the application first checks the cache. On a cache miss, it queries the database, stores the result in the cache, and returns it. On subsequent reads the cached value is served directly. This pattern is simple but can lead to stale data if the database is updated without invalidating the cache.',
        difficulty: 'intermediate',
        tags: ['caching', 'patterns'],
      },
      {
        id: 'system-design-q5',
        question: 'What problem does database sharding solve?',
        options: [
          { id: 'system-design-q5-a', text: 'It encrypts sensitive database fields' },
          { id: 'system-design-q5-b', text: 'It distributes data across multiple databases to handle datasets that exceed a single machine\'s capacity' },
          { id: 'system-design-q5-c', text: 'It creates real-time replicas for read scaling only' },
          { id: 'system-design-q5-d', text: 'It normalizes the schema to reduce redundancy' },
        ],
        correctOptionId: 'system-design-q5-b',
        explanation: 'Sharding partitions data horizontally across multiple database instances (shards), each holding a subset of the total data. This enables horizontal scaling of write throughput and storage capacity beyond what a single server can handle. The trade-off is increased complexity for cross-shard queries and data rebalancing.',
        difficulty: 'intermediate',
        tags: ['databases', 'sharding', 'scalability'],
      },
      {
        id: 'system-design-q6',
        question: 'What is the purpose of a message queue (e.g., Kafka, RabbitMQ) in a distributed system?',
        options: [
          { id: 'system-design-q6-a', text: 'To replace REST APIs with faster communication' },
          { id: 'system-design-q6-b', text: 'To decouple producers and consumers, enable async processing, and buffer traffic spikes' },
          { id: 'system-design-q6-c', text: 'To store permanent application data like a database' },
          { id: 'system-design-q6-d', text: 'To serve static files to end users' },
        ],
        correctOptionId: 'system-design-q6-b',
        explanation: 'Message queues decouple service communication so producers and consumers operate independently. They enable asynchronous processing (the producer does not wait for the consumer), buffer traffic spikes to prevent overload, and provide durability so messages survive consumer downtime.',
        difficulty: 'intermediate',
        tags: ['message-queues', 'async'],
      },
      {
        id: 'system-design-q7',
        question: 'What is consistent hashing and why is it used?',
        options: [
          { id: 'system-design-q7-a', text: 'A hashing algorithm that guarantees zero collisions' },
          { id: 'system-design-q7-b', text: 'A technique that minimizes key redistribution when the number of servers changes' },
          { id: 'system-design-q7-c', text: 'A method to ensure all hash values are the same length' },
          { id: 'system-design-q7-d', text: 'An encryption technique for securing API keys' },
        ],
        correctOptionId: 'system-design-q7-b',
        explanation: 'Consistent hashing maps both keys and servers onto a virtual ring. When a server is added or removed, only a fraction of keys need to be remapped (roughly K/N where K is total keys and N is servers). This is critical for distributed caches and databases where rehashing everything would cause massive cache misses.',
        difficulty: 'advanced',
        tags: ['hashing', 'distributed-systems'],
      },
      {
        id: 'system-design-q8',
        question: 'What is an API gateway and what problems does it solve?',
        options: [
          { id: 'system-design-q8-a', text: 'A database proxy that caches query results' },
          { id: 'system-design-q8-b', text: 'A single entry point that handles routing, auth, rate limiting, and aggregation for microservices' },
          { id: 'system-design-q8-c', text: 'A tool that automatically generates API documentation' },
          { id: 'system-design-q8-d', text: 'A CDN node that serves static assets' },
        ],
        correctOptionId: 'system-design-q8-b',
        explanation: 'An API gateway is a reverse proxy that sits between clients and backend microservices. It handles cross-cutting concerns like authentication, rate limiting, request routing, response aggregation, and protocol translation. This prevents clients from needing to know about individual service addresses.',
        difficulty: 'intermediate',
        tags: ['api-gateway', 'microservices'],
      },
      {
        id: 'system-design-q9',
        question: 'What does eventual consistency mean in distributed systems?',
        options: [
          { id: 'system-design-q9-a', text: 'All nodes always return the latest written value' },
          { id: 'system-design-q9-b', text: 'If no new writes occur, all replicas will eventually converge to the same value' },
          { id: 'system-design-q9-c', text: 'The system is inconsistent and data loss is expected' },
          { id: 'system-design-q9-d', text: 'Reads are never consistent and always return stale data' },
        ],
        correctOptionId: 'system-design-q9-b',
        explanation: 'Eventual consistency guarantees that if no new updates are made, all replicas will eventually return the last written value. It trades immediate consistency for better availability and lower latency. Systems like DynamoDB and Cassandra use this model with tunable consistency levels.',
        difficulty: 'advanced',
        tags: ['consistency', 'distributed-systems'],
      },
      {
        id: 'system-design-q10',
        question: 'Which technique is most appropriate for generating globally unique, time-sortable IDs in a distributed system?',
        options: [
          { id: 'system-design-q10-a', text: 'Auto-incrementing integer from a single database' },
          { id: 'system-design-q10-b', text: 'Random UUID v4' },
          { id: 'system-design-q10-c', text: 'Snowflake IDs or ULID (Universally Unique Lexicographically Sortable Identifier)' },
          { id: 'system-design-q10-d', text: 'MD5 hash of the current timestamp' },
        ],
        correctOptionId: 'system-design-q10-c',
        explanation: 'Snowflake IDs (designed by Twitter) and ULIDs embed a timestamp component making them time-sortable while maintaining uniqueness across distributed nodes via machine/worker bits. Auto-increment requires coordination, UUIDs are not sortable, and MD5 hashes can collide and are not designed for ID generation.',
        difficulty: 'advanced',
        tags: ['id-generation', 'distributed-systems'],
      },
    ],
  },

  // ─── 6. Node.js ────────────────────────────────────────────────────────────
  {
    id: 'nodejs',
    title: 'Node.js',
    description: 'Event loop, streams, modules, async patterns, and runtime internals.',
    icon: 'Server',
    gradient: 'from-green-500 to-emerald-600',
    category: 'Backend',
    questions: [
      {
        id: 'nodejs-q1',
        question: 'What is the Node.js event loop?',
        options: [
          { id: 'nodejs-q1-a', text: 'A multi-threaded task scheduler' },
          { id: 'nodejs-q1-b', text: 'A single-threaded mechanism that processes asynchronous callbacks in phases' },
          { id: 'nodejs-q1-c', text: 'A built-in HTTP server' },
          { id: 'nodejs-q1-d', text: 'A garbage collection process' },
        ],
        correctOptionId: 'nodejs-q1-b',
        explanation: 'The event loop is the core mechanism that allows Node.js to perform non-blocking I/O despite being single-threaded. It processes callbacks in distinct phases (timers, I/O callbacks, idle/prepare, poll, check, close) and delegates heavy work to the libuv thread pool.',
        difficulty: 'beginner',
        tags: ['event-loop', 'fundamentals'],
      },
      {
        id: 'nodejs-q2',
        question: 'What is the difference between require() and import in Node.js?',
        options: [
          { id: 'nodejs-q2-a', text: 'require() is CommonJS and synchronous; import is ESM and can be statically analyzed' },
          { id: 'nodejs-q2-b', text: 'They are identical; import is just newer syntax' },
          { id: 'nodejs-q2-c', text: 'require() works in browsers; import works only in Node.js' },
          { id: 'nodejs-q2-d', text: 'import can only load JSON files; require() loads JavaScript' },
        ],
        correctOptionId: 'nodejs-q2-a',
        explanation: 'require() is the CommonJS module system, loading modules synchronously at runtime. ESM import/export is statically analyzable at parse time, enabling tree-shaking and better tooling. Node.js supports both, but ESM requires "type": "module" in package.json or .mjs file extension.',
        difficulty: 'beginner',
        tags: ['modules', 'commonjs', 'esm'],
      },
      {
        id: 'nodejs-q3',
        question: 'What will this code output?',
        codeSnippet: 'console.log("A");\nsetImmediate(() => console.log("B"));\nprocess.nextTick(() => console.log("C"));\nPromise.resolve().then(() => console.log("D"));\nconsole.log("E");',
        options: [
          { id: 'nodejs-q3-a', text: 'A, E, C, D, B' },
          { id: 'nodejs-q3-b', text: 'A, E, B, C, D' },
          { id: 'nodejs-q3-c', text: 'A, B, C, D, E' },
          { id: 'nodejs-q3-d', text: 'A, E, D, C, B' },
        ],
        correctOptionId: 'nodejs-q3-a',
        explanation: 'Synchronous code runs first (A, E). Then the microtask queue is processed: process.nextTick has higher priority than Promise microtasks, so C comes before D. Finally, setImmediate runs in the check phase of the next event loop iteration, outputting B last.',
        difficulty: 'advanced',
        tags: ['event-loop', 'async', 'microtasks'],
      },
      {
        id: 'nodejs-q4',
        question: 'What are Node.js streams and why are they useful?',
        options: [
          { id: 'nodejs-q4-a', text: 'A way to render video content in the browser' },
          { id: 'nodejs-q4-b', text: 'Interfaces for processing data piece by piece without loading it all into memory' },
          { id: 'nodejs-q4-c', text: 'A logging framework built into Node.js' },
          { id: 'nodejs-q4-d', text: 'A method for sending HTTP requests in parallel' },
        ],
        correctOptionId: 'nodejs-q4-b',
        explanation: 'Streams allow you to read or write data in chunks rather than loading entire files or responses into memory. Node.js has four stream types: Readable, Writable, Duplex, and Transform. They are essential for processing large files, network data, and piping data between sources and destinations efficiently.',
        difficulty: 'intermediate',
        tags: ['streams', 'performance'],
      },
      {
        id: 'nodejs-q5',
        question: 'What does the cluster module in Node.js do?',
        options: [
          { id: 'nodejs-q5-a', text: 'It connects to a MongoDB cluster' },
          { id: 'nodejs-q5-b', text: 'It forks multiple worker processes to utilize all CPU cores' },
          { id: 'nodejs-q5-c', text: 'It clusters related files into a single bundle' },
          { id: 'nodejs-q5-d', text: 'It manages Docker container clusters' },
        ],
        correctOptionId: 'nodejs-q5-b',
        explanation: 'The cluster module allows you to fork multiple child processes (workers) that share the same server port. Since Node.js is single-threaded, this is how you utilize multiple CPU cores. The master process distributes incoming connections to workers, typically one worker per core.',
        difficulty: 'intermediate',
        tags: ['cluster', 'scaling'],
      },
      {
        id: 'nodejs-q6',
        question: 'What is the purpose of the package-lock.json file?',
        options: [
          { id: 'nodejs-q6-a', text: 'It prevents other developers from modifying package.json' },
          { id: 'nodejs-q6-b', text: 'It locks the exact dependency tree for reproducible installations across environments' },
          { id: 'nodejs-q6-c', text: 'It stores authentication tokens for private registries' },
          { id: 'nodejs-q6-d', text: 'It is a backup copy of package.json' },
        ],
        correctOptionId: 'nodejs-q6-b',
        explanation: 'package-lock.json records the exact version of every installed dependency and its sub-dependencies. This ensures that npm install produces the identical dependency tree across all machines and CI environments, preventing "works on my machine" bugs caused by version drift.',
        difficulty: 'beginner',
        tags: ['npm', 'dependencies'],
      },
      {
        id: 'nodejs-q7',
        question: 'What is middleware in Express.js?',
        codeSnippet: 'app.use((req, res, next) => {\n  console.log(`${req.method} ${req.url}`);\n  next();\n});',
        options: [
          { id: 'nodejs-q7-a', text: 'A database connection layer' },
          { id: 'nodejs-q7-b', text: 'Functions that have access to request, response, and next, executing in the request pipeline' },
          { id: 'nodejs-q7-c', text: 'A template rendering engine' },
          { id: 'nodejs-q7-d', text: 'A caching layer between the client and server' },
        ],
        correctOptionId: 'nodejs-q7-b',
        explanation: 'Express middleware functions receive the request, response, and next function. They can execute code, modify req/res, end the request cycle, or call next() to pass control. Middleware runs in order and is used for logging, authentication, parsing, error handling, and more.',
        difficulty: 'intermediate',
        tags: ['express', 'middleware'],
      },
      {
        id: 'nodejs-q8',
        question: 'What is the difference between process.nextTick() and setImmediate()?',
        options: [
          { id: 'nodejs-q8-a', text: 'They are identical in behavior' },
          { id: 'nodejs-q8-b', text: 'nextTick fires before any I/O events; setImmediate fires in the check phase after I/O' },
          { id: 'nodejs-q8-c', text: 'setImmediate fires before nextTick' },
          { id: 'nodejs-q8-d', text: 'nextTick is deprecated in favor of setImmediate' },
        ],
        correctOptionId: 'nodejs-q8-b',
        explanation: 'process.nextTick() callbacks are processed after the current operation and before the event loop continues, meaning they fire before any I/O events. setImmediate() callbacks execute in the check phase, after the poll phase processes I/O. Recursive nextTick can starve I/O, so setImmediate is generally safer for deferring work.',
        difficulty: 'advanced',
        tags: ['event-loop', 'async'],
      },
      {
        id: 'nodejs-q9',
        question: 'How does Node.js handle errors in async/await code?',
        codeSnippet: 'async function fetchData() {\n  const res = await fetch("https://api.example.com/data");\n  if (!res.ok) throw new Error("Fetch failed");\n  return res.json();\n}',
        options: [
          { id: 'nodejs-q9-a', text: 'Errors are silently ignored' },
          { id: 'nodejs-q9-b', text: 'Errors reject the returned promise and should be caught with try/catch or .catch()' },
          { id: 'nodejs-q9-c', text: 'Errors crash the process immediately' },
          { id: 'nodejs-q9-d', text: 'Errors are logged to stderr automatically' },
        ],
        correctOptionId: 'nodejs-q9-b',
        explanation: 'When an async function throws (or an awaited promise rejects), the error rejects the promise returned by the async function. Callers should use try/catch within another async function or .catch() on the returned promise. Unhandled rejections trigger the unhandledRejection event and may terminate the process in newer Node.js versions.',
        difficulty: 'intermediate',
        tags: ['async-await', 'error-handling'],
      },
      {
        id: 'nodejs-q10',
        question: 'What is the worker_threads module used for in Node.js?',
        options: [
          { id: 'nodejs-q10-a', text: 'Creating web workers for browser-based JavaScript' },
          { id: 'nodejs-q10-b', text: 'Running JavaScript in parallel threads for CPU-intensive tasks without blocking the event loop' },
          { id: 'nodejs-q10-c', text: 'Managing a pool of database connections' },
          { id: 'nodejs-q10-d', text: 'Spawning child processes that run shell commands' },
        ],
        correctOptionId: 'nodejs-q10-b',
        explanation: 'The worker_threads module enables running JavaScript code in parallel threads. Unlike the cluster module (which forks processes), worker threads share memory via SharedArrayBuffer and are ideal for CPU-intensive operations like image processing, compression, or complex calculations without blocking the main event loop.',
        difficulty: 'advanced',
        tags: ['worker-threads', 'concurrency'],
      },
    ],
  },

  // ─── 7. SQL & Databases ────────────────────────────────────────────────────
  {
    id: 'sql-databases',
    title: 'SQL & Databases',
    description: 'Queries, joins, indexing, transactions, and database design.',
    icon: 'Database',
    gradient: 'from-amber-500 to-orange-600',
    category: 'Backend',
    questions: [
      {
        id: 'sql-databases-q1',
        question: 'What is the difference between INNER JOIN and LEFT JOIN?',
        options: [
          { id: 'sql-databases-q1-a', text: 'INNER JOIN returns only matching rows; LEFT JOIN returns all left rows plus matches from the right' },
          { id: 'sql-databases-q1-b', text: 'LEFT JOIN returns only matching rows; INNER JOIN returns all rows' },
          { id: 'sql-databases-q1-c', text: 'They are the same but with different syntax' },
          { id: 'sql-databases-q1-d', text: 'INNER JOIN works with two tables; LEFT JOIN works with three or more' },
        ],
        correctOptionId: 'sql-databases-q1-a',
        explanation: 'INNER JOIN returns only rows that have matching values in both tables. LEFT JOIN (or LEFT OUTER JOIN) returns all rows from the left table and the matched rows from the right table. If there is no match, NULL values are returned for the right table columns.',
        difficulty: 'beginner',
        tags: ['joins', 'fundamentals'],
      },
      {
        id: 'sql-databases-q2',
        question: 'What does the HAVING clause do and how does it differ from WHERE?',
        codeSnippet: 'SELECT department, COUNT(*) as emp_count\nFROM employees\nGROUP BY department\nHAVING COUNT(*) > 5;',
        options: [
          { id: 'sql-databases-q2-a', text: 'HAVING and WHERE are interchangeable' },
          { id: 'sql-databases-q2-b', text: 'HAVING filters groups after GROUP BY; WHERE filters rows before GROUP BY' },
          { id: 'sql-databases-q2-c', text: 'HAVING is used for joins; WHERE is used for subqueries' },
          { id: 'sql-databases-q2-d', text: 'WHERE works with aggregates; HAVING works with individual columns' },
        ],
        correctOptionId: 'sql-databases-q2-b',
        explanation: 'WHERE filters individual rows before any grouping or aggregation occurs. HAVING filters groups after GROUP BY has been applied. You cannot use aggregate functions (COUNT, SUM, AVG) in a WHERE clause; HAVING is specifically designed for filtering on aggregated results.',
        difficulty: 'beginner',
        tags: ['aggregation', 'filtering'],
      },
      {
        id: 'sql-databases-q3',
        question: 'What is a database index and what trade-off does it introduce?',
        options: [
          { id: 'sql-databases-q3-a', text: 'An index is a backup of the table; the trade-off is storage cost' },
          { id: 'sql-databases-q3-b', text: 'An index speeds up reads but slows down writes and uses additional storage' },
          { id: 'sql-databases-q3-c', text: 'An index reorders the table physically; the trade-off is data corruption risk' },
          { id: 'sql-databases-q3-d', text: 'An index is a cache in RAM; the trade-off is memory usage only' },
        ],
        correctOptionId: 'sql-databases-q3-b',
        explanation: 'A database index is a data structure (typically B-tree or hash) that speeds up data retrieval on indexed columns. The trade-off is that every INSERT, UPDATE, or DELETE must also update the index, slowing write operations. Indexes also consume additional disk space.',
        difficulty: 'beginner',
        tags: ['indexing', 'performance'],
      },
      {
        id: 'sql-databases-q4',
        question: 'What are the ACID properties of a database transaction?',
        options: [
          { id: 'sql-databases-q4-a', text: 'Authentication, Concurrency, Isolation, Durability' },
          { id: 'sql-databases-q4-b', text: 'Atomicity, Consistency, Isolation, Durability' },
          { id: 'sql-databases-q4-c', text: 'Availability, Consistency, Integrity, Distribution' },
          { id: 'sql-databases-q4-d', text: 'Atomicity, Caching, Indexing, Decoupling' },
        ],
        correctOptionId: 'sql-databases-q4-b',
        explanation: 'ACID stands for Atomicity (all or nothing), Consistency (valid state transitions), Isolation (concurrent transactions do not interfere), and Durability (committed data survives crashes). These properties guarantee reliable transaction processing in relational databases.',
        difficulty: 'intermediate',
        tags: ['transactions', 'acid'],
      },
      {
        id: 'sql-databases-q5',
        question: 'What is the result of this query?',
        codeSnippet: 'SELECT COALESCE(NULL, NULL, \'default\', \'other\');',
        options: [
          { id: 'sql-databases-q5-a', text: 'NULL' },
          { id: 'sql-databases-q5-b', text: '\'default\'' },
          { id: 'sql-databases-q5-c', text: '\'other\'' },
          { id: 'sql-databases-q5-d', text: 'An error because of multiple NULLs' },
        ],
        correctOptionId: 'sql-databases-q5-b',
        explanation: 'COALESCE returns the first non-NULL argument from the list. It evaluates from left to right: NULL (skip), NULL (skip), \'default\' (first non-NULL, return this). It never reaches \'other\'. COALESCE is commonly used for providing fallback values.',
        difficulty: 'intermediate',
        tags: ['functions', 'null-handling'],
      },
      {
        id: 'sql-databases-q6',
        question: 'What is database normalization and what does Third Normal Form (3NF) require?',
        options: [
          { id: 'sql-databases-q6-a', text: 'Storing all data in a single table for maximum performance' },
          { id: 'sql-databases-q6-b', text: 'Organizing data to reduce redundancy; 3NF requires no transitive dependencies on the primary key' },
          { id: 'sql-databases-q6-c', text: 'Encrypting all columns that contain PII' },
          { id: 'sql-databases-q6-d', text: 'Creating indexes on every column' },
        ],
        correctOptionId: 'sql-databases-q6-b',
        explanation: 'Normalization structures a relational database to reduce data redundancy and improve integrity. Third Normal Form (3NF) requires that a table is in 2NF and that all non-key columns depend directly on the primary key, not on other non-key columns (no transitive dependencies).',
        difficulty: 'intermediate',
        tags: ['normalization', 'design'],
      },
      {
        id: 'sql-databases-q7',
        question: 'What is the difference between a clustered and a non-clustered index?',
        options: [
          { id: 'sql-databases-q7-a', text: 'Clustered indexes sort and store the actual data rows; non-clustered indexes store pointers to rows' },
          { id: 'sql-databases-q7-b', text: 'Non-clustered indexes sort the data rows; clustered indexes store pointers' },
          { id: 'sql-databases-q7-c', text: 'Clustered indexes work across multiple servers; non-clustered are local only' },
          { id: 'sql-databases-q7-d', text: 'There is no difference; the terms are interchangeable' },
        ],
        correctOptionId: 'sql-databases-q7-a',
        explanation: 'A clustered index determines the physical order of data rows in a table, so a table can have only one clustered index (typically on the primary key). Non-clustered indexes are separate structures that contain the indexed columns plus a pointer (row locator) back to the actual data row.',
        difficulty: 'advanced',
        tags: ['indexing', 'performance'],
      },
      {
        id: 'sql-databases-q8',
        question: 'What does the EXPLAIN command do in SQL?',
        codeSnippet: 'EXPLAIN ANALYZE SELECT * FROM orders\nWHERE customer_id = 42\nORDER BY created_at DESC;',
        options: [
          { id: 'sql-databases-q8-a', text: 'It describes the table schema' },
          { id: 'sql-databases-q8-b', text: 'It shows the query execution plan including how the database will access data' },
          { id: 'sql-databases-q8-c', text: 'It runs the query and displays the results in a formatted table' },
          { id: 'sql-databases-q8-d', text: 'It validates the SQL syntax without executing it' },
        ],
        correctOptionId: 'sql-databases-q8-b',
        explanation: 'EXPLAIN shows the query execution plan the database optimizer chooses, including which indexes are used, join strategies, and estimated costs. EXPLAIN ANALYZE actually executes the query and shows real timing data alongside the plan. This is essential for identifying and fixing slow queries.',
        difficulty: 'intermediate',
        tags: ['performance', 'query-optimization'],
      },
      {
        id: 'sql-databases-q9',
        question: 'What is a Common Table Expression (CTE) and when would you use one?',
        codeSnippet: 'WITH active_users AS (\n  SELECT id, name FROM users WHERE status = \'active\'\n)\nSELECT a.name, COUNT(o.id)\nFROM active_users a\nJOIN orders o ON o.user_id = a.id\nGROUP BY a.name;',
        options: [
          { id: 'sql-databases-q9-a', text: 'A permanent view stored in the database catalog' },
          { id: 'sql-databases-q9-b', text: 'A temporary named result set defined within a single statement for readability and reuse' },
          { id: 'sql-databases-q9-c', text: 'A stored procedure that returns a table' },
          { id: 'sql-databases-q9-d', text: 'An alias for a subquery that improves performance' },
        ],
        correctOptionId: 'sql-databases-q9-b',
        explanation: 'A CTE (defined with WITH) creates a temporary, named result set that exists only for the duration of the query. CTEs improve readability by breaking complex queries into named steps and can be referenced multiple times. Recursive CTEs are also possible for hierarchical data traversal.',
        difficulty: 'advanced',
        tags: ['cte', 'advanced-sql'],
      },
      {
        id: 'sql-databases-q10',
        question: 'What is a deadlock in a database context?',
        options: [
          { id: 'sql-databases-q10-a', text: 'A query that takes too long and times out' },
          { id: 'sql-databases-q10-b', text: 'Two or more transactions waiting for each other to release locks, causing them all to block indefinitely' },
          { id: 'sql-databases-q10-c', text: 'A table that has reached its maximum row limit' },
          { id: 'sql-databases-q10-d', text: 'A corrupted index that prevents reads' },
        ],
        correctOptionId: 'sql-databases-q10-b',
        explanation: 'A deadlock occurs when two or more transactions each hold a lock that the other needs, creating a circular dependency where none can proceed. Databases detect deadlocks and resolve them by rolling back one of the transactions (the victim). Preventing deadlocks involves consistent lock ordering and keeping transactions short.',
        difficulty: 'advanced',
        tags: ['transactions', 'concurrency', 'deadlocks'],
      },
    ],
  },

  // ─── 8. Git & CI/CD ───────────────────────────────────────────────────────
  {
    id: 'git-cicd',
    title: 'Git & CI/CD',
    description: 'Version control, branching strategies, pipelines, and deployment.',
    icon: 'GitBranch',
    gradient: 'from-rose-500 to-red-600',
    category: 'DevOps',
    questions: [
      {
        id: 'git-cicd-q1',
        question: 'What is the difference between git merge and git rebase?',
        options: [
          { id: 'git-cicd-q1-a', text: 'They are the same operation with different names' },
          { id: 'git-cicd-q1-b', text: 'Merge creates a merge commit preserving history; rebase replays commits on top of another branch for a linear history' },
          { id: 'git-cicd-q1-c', text: 'Rebase creates a merge commit; merge replays commits' },
          { id: 'git-cicd-q1-d', text: 'Merge only works on local branches; rebase works on remote branches' },
        ],
        correctOptionId: 'git-cicd-q1-b',
        explanation: 'git merge integrates changes by creating a new merge commit that ties together the histories of both branches. git rebase moves your commits to the tip of the target branch, rewriting history for a cleaner, linear commit log. Rebase should not be used on shared/public branches as it rewrites commit hashes.',
        difficulty: 'beginner',
        tags: ['git', 'branching'],
      },
      {
        id: 'git-cicd-q2',
        question: 'What does git stash do?',
        options: [
          { id: 'git-cicd-q2-a', text: 'Permanently deletes uncommitted changes' },
          { id: 'git-cicd-q2-b', text: 'Temporarily saves uncommitted changes so you can switch branches cleanly' },
          { id: 'git-cicd-q2-c', text: 'Creates a new branch from the current changes' },
          { id: 'git-cicd-q2-d', text: 'Commits changes without a message' },
        ],
        correctOptionId: 'git-cicd-q2-b',
        explanation: 'git stash saves your modified tracked files and staged changes onto a stack, reverting your working directory to match HEAD. You can later reapply stashed changes with git stash pop or git stash apply. This is useful when you need to quickly switch context without committing incomplete work.',
        difficulty: 'beginner',
        tags: ['git', 'workflow'],
      },
      {
        id: 'git-cicd-q3',
        question: 'What is the purpose of a CI/CD pipeline?',
        options: [
          { id: 'git-cicd-q3-a', text: 'To replace version control systems' },
          { id: 'git-cicd-q3-b', text: 'To automate building, testing, and deploying code changes' },
          { id: 'git-cicd-q3-c', text: 'To manage project documentation' },
          { id: 'git-cicd-q3-d', text: 'To assign tasks to team members' },
        ],
        correctOptionId: 'git-cicd-q3-b',
        explanation: 'CI/CD (Continuous Integration/Continuous Delivery or Deployment) pipelines automate the software delivery process. CI automatically builds and tests code on every push. CD automatically deploys passing builds to staging or production. This reduces manual errors, provides fast feedback, and enables frequent reliable releases.',
        difficulty: 'beginner',
        tags: ['cicd', 'automation'],
      },
      {
        id: 'git-cicd-q4',
        question: 'What is the difference between git reset --soft, --mixed, and --hard?',
        codeSnippet: 'git reset --soft HEAD~1   # Option A\ngit reset --mixed HEAD~1  # Option B\ngit reset --hard HEAD~1   # Option C',
        options: [
          { id: 'git-cicd-q4-a', text: 'soft keeps staged + working; mixed unstages but keeps working; hard discards everything' },
          { id: 'git-cicd-q4-b', text: 'They all do the same thing but with different speed' },
          { id: 'git-cicd-q4-c', text: 'soft deletes commits; mixed and hard only move the branch pointer' },
          { id: 'git-cicd-q4-d', text: 'hard is the safest; soft is the most destructive' },
        ],
        correctOptionId: 'git-cicd-q4-a',
        explanation: '--soft moves HEAD but keeps changes staged and in the working directory. --mixed (default) moves HEAD and unstages changes but keeps them in the working directory. --hard moves HEAD and discards all changes in both the staging area and working directory. --hard is destructive and cannot be easily undone.',
        difficulty: 'intermediate',
        tags: ['git', 'reset'],
      },
      {
        id: 'git-cicd-q5',
        question: 'What is GitFlow and what are its main branches?',
        options: [
          { id: 'git-cicd-q5-a', text: 'A Git GUI tool with branches named alpha and beta' },
          { id: 'git-cicd-q5-b', text: 'A branching model with main, develop, feature, release, and hotfix branches' },
          { id: 'git-cicd-q5-c', text: 'A CI/CD tool that only uses the main branch' },
          { id: 'git-cicd-q5-d', text: 'A rebase-only workflow with no merge commits' },
        ],
        correctOptionId: 'git-cicd-q5-b',
        explanation: 'GitFlow is a branching model that uses two long-lived branches (main for production, develop for integration) and three short-lived branch types (feature, release, hotfix). Features are developed on feature branches, merged into develop, then promoted through release branches to main. It suits projects with scheduled releases.',
        difficulty: 'intermediate',
        tags: ['git', 'branching-strategy'],
      },
      {
        id: 'git-cicd-q6',
        question: 'What does git cherry-pick do?',
        codeSnippet: 'git cherry-pick abc1234',
        options: [
          { id: 'git-cicd-q6-a', text: 'Deletes the specified commit from history' },
          { id: 'git-cicd-q6-b', text: 'Applies the changes from a specific commit onto the current branch' },
          { id: 'git-cicd-q6-c', text: 'Marks a commit as a favorite for later reference' },
          { id: 'git-cicd-q6-d', text: 'Reverts all changes since the specified commit' },
        ],
        correctOptionId: 'git-cicd-q6-b',
        explanation: 'git cherry-pick takes the changes introduced by a specific commit and applies them as a new commit on the current branch. It creates a new commit with a different hash but the same diff. This is useful for selectively backporting fixes from one branch to another without merging the entire branch.',
        difficulty: 'intermediate',
        tags: ['git', 'cherry-pick'],
      },
      {
        id: 'git-cicd-q7',
        question: 'In a GitHub Actions workflow, what does the `on` key specify?',
        codeSnippet: 'on:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]',
        options: [
          { id: 'git-cicd-q7-a', text: 'The environment variables for the workflow' },
          { id: 'git-cicd-q7-b', text: 'The events that trigger the workflow to run' },
          { id: 'git-cicd-q7-c', text: 'The list of jobs to execute' },
          { id: 'git-cicd-q7-d', text: 'The Docker image to use for the runner' },
        ],
        correctOptionId: 'git-cicd-q7-b',
        explanation: 'The `on` key in a GitHub Actions workflow file defines the trigger events. In this example, the workflow runs on pushes to main and on pull requests targeting main. Other triggers include schedule (cron), workflow_dispatch (manual), and repository_dispatch (API-triggered).',
        difficulty: 'intermediate',
        tags: ['github-actions', 'cicd'],
      },
      {
        id: 'git-cicd-q8',
        question: 'What is a blue-green deployment strategy?',
        options: [
          { id: 'git-cicd-q8-a', text: 'Deploying to two separate regions simultaneously' },
          { id: 'git-cicd-q8-b', text: 'Running two identical production environments and switching traffic from old (blue) to new (green) instantly' },
          { id: 'git-cicd-q8-c', text: 'Gradually rolling out updates to a percentage of users' },
          { id: 'git-cicd-q8-d', text: 'Testing in staging before deploying to production' },
        ],
        correctOptionId: 'git-cicd-q8-b',
        explanation: 'Blue-green deployment maintains two identical production environments. The current version runs on "blue" while the new version is deployed to "green." After testing green, traffic is switched from blue to green. If issues arise, you instantly roll back by routing traffic back to blue. The trade-off is double the infrastructure cost.',
        difficulty: 'advanced',
        tags: ['deployment', 'strategies'],
      },
      {
        id: 'git-cicd-q9',
        question: 'What is the purpose of git bisect?',
        options: [
          { id: 'git-cicd-q9-a', text: 'To split a large commit into smaller ones' },
          { id: 'git-cicd-q9-b', text: 'To perform a binary search through commit history to find the commit that introduced a bug' },
          { id: 'git-cicd-q9-c', text: 'To merge two branches simultaneously' },
          { id: 'git-cicd-q9-d', text: 'To remove duplicate commits from history' },
        ],
        correctOptionId: 'git-cicd-q9-b',
        explanation: 'git bisect uses a binary search algorithm to efficiently find the commit that introduced a bug. You mark a known good commit and a known bad commit, and bisect checks out the midpoint for you to test. Each step halves the remaining commits, finding the culprit in O(log n) steps.',
        difficulty: 'advanced',
        tags: ['git', 'debugging'],
      },
      {
        id: 'git-cicd-q10',
        question: 'What is a canary deployment and how does it differ from blue-green?',
        options: [
          { id: 'git-cicd-q10-a', text: 'Canary deploys to a single server; blue-green deploys to all servers' },
          { id: 'git-cicd-q10-b', text: 'Canary gradually routes a small percentage of traffic to the new version; blue-green switches all traffic at once' },
          { id: 'git-cicd-q10-c', text: 'They are the same strategy with different names' },
          { id: 'git-cicd-q10-d', text: 'Canary is for frontend; blue-green is for backend' },
        ],
        correctOptionId: 'git-cicd-q10-b',
        explanation: 'Canary deployment routes a small percentage of traffic (e.g., 5%) to the new version while the majority stays on the old version. If metrics are healthy, traffic is gradually increased. Unlike blue-green which is all-or-nothing, canary limits blast radius by exposing only a fraction of users to potential issues.',
        difficulty: 'advanced',
        tags: ['deployment', 'strategies'],
      },
    ],
  },
];
